<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go设计模式 on Amazing-Gao 实在是高</title><link>/series/go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in Go设计模式 on Amazing-Gao 实在是高</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>amazing.gao@qq.com (AmazingGao)</managingEditor><webMaster>amazing.gao@qq.com (AmazingGao)</webMaster><copyright>Amazing-Gao — All rights reserved.</copyright><lastBuildDate>Wed, 14 Oct 2020 20:30:39 +0800</lastBuildDate><atom:link href="/series/go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>Go设计模式之Factory</title><link>/posts/2020/10/factory/</link><pubDate>Wed, 14 Oct 2020 20:30:39 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/10/factory/</guid><description>Factory - 工厂模式 工厂模式在Go中使用的非常广泛，比如常用于数据的读写模块。假设我们需要从某种介质中读取数据，并将更新后的结果保存到该介质中。考虑到以后可能更换为其他类型的介质，为了避免日后更换介质而大面积变更代码，我们就会用到本模式。
实现 1.定义工厂方法所创建对象的接口 假设我们的存储模块只有Read和Write两个功能，我们需要先定义存储器inteface。
1package store 2 3import &amp;#34;io&amp;#34; 4 5type Store interface { 6 Read(string) ([]byte, error) 7 Save(string, []byte) (error) 8} 2.实现对象接口 假设我们需要将Redis或磁盘作为存储介质，我们需要分别实现Redis与磁盘的存储功能。
FileSystem 1pacakge store 2 3type FileStore struct{ 4 /*your codes*/ 5} 6 7func (store *FileStore) Read(string) ([]byte, error) { 8 /*your codes*/ 9} 10 11func (store *FileStore) Save(string, []byte) (error) { 12 /*your codes*/ 13} 14 15// 注意这里要返回 Store 接口，而不是FileStore的指针。 16// 可以保证工厂方法只能调用到对象接口方法，避免封装被破坏。 17func newFileStore() Store { 18 /*your codes*/ 19} Redis 1pacakge store 2 3type RedisStore struct{ 4 /*your codes*/ 5} 6 7func (store *RedisStore) Read(string) ([]byte, error) { 8 /*your codes*/ 9} 10 11func (store *RedisStore) Save(string, []byte) (error) { 12 /*your codes*/ 13} 14 15// 注意这里要返回 Store 接口，而不是RedisStore的指针。 16// 可以保证工厂方法只能调用到对象接口方法，避免封装被破坏。 17func newRedisStore() Store { 18 /*your codes*/ 19} 3.</description></item><item><title>Go设计模式之Singleton</title><link>/posts/2020/09/go-patterns/singleton/</link><pubDate>Wed, 30 Sep 2020 22:40:58 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/09/go-patterns/singleton/</guid><description>Singleton - 单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点。
实现 饿汉式 饿汉式单例是指在方法调用前，实例就已经创建好了。
按照用法使用，可以看到控制台输出10次单例的内存地址是一样的。
1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;sync&amp;#34; 6 &amp;#34;time&amp;#34; 7) 8 9type ( 10 server struct { 11 port int 12 } 13) 14 15var ( 16 instance = &amp;amp;server{} 17) 18 19func getServerSingleton() *server { 20 return instance 21} 22 23/* 24server ptr: 0x1182ec0 25server ptr: 0x1182ec0 26server ptr: 0x1182ec0 27server ptr: 0x1182ec0 28server ptr: 0x1182ec0 29server ptr: 0x1182ec0 30server ptr: 0x1182ec0 31server ptr: 0x1182ec0 32server ptr: 0x1182ec0 33server ptr: 0x1182ec0 34*/ 懒汉式 - 非Goroutine安全 懒汉式单例是指在方法调用获取实例时才创建实例，因为相对饿汉式显得“不急迫”，所以被叫做“懒汉模式”。</description></item></channel></rss>