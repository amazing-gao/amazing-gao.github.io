<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>Amazing-Gao 实在是高</title><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=description content="实在是高的个人技术博客"><meta name=author content="AmazingGao"><meta name=generator content="Hugo 0.78.1"><link href=/index.xml rel=alternate type=application/rss+xml title="Amazing-Gao 实在是高 Feed"><link rel=stylesheet href=/style.7c6d960b20273ed88bc63a60591a57e7739fb21f243b77f27c3bc730ef6205c0.css><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?815a521e3c0aee7749c5f8350acb8c6d";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script><script defer src=/script.9df38729991a6ec08d83b60514e841529cebd5ccc800cf8e1f98fb63e73aaa73.js></script></head><body><div class=pure-g><div class="pure-u-1-24 pure-u-md-5-24"></div><div class="pure-u-22-24 pure-u-md-14-24"><div class=navigation><div class="navigation-header clearfix"><div class="pure-menu pure-menu-horizontal"><a class="pure-menu-heading pure-menu-link" href=/>Amazing-Gao 实在是高</a><ul class="pure-menu-list navigation-header-subtitle pull-end"><li class="pure-menu-item pure-menu-disabled">Find, discover, explorer and enjoy!</li></ul></div></div><div class=navigation-content><div class="pure-menu pure-menu-horizontal"><ul class=pure-menu-list><li class=pure-menu-item title="All posts"><a class=pure-menu-link href=/posts/>Posts</a></li><li class=pure-menu-item title="All tags"><a class=pure-menu-link href=/tags/>Tags</a></li><li class=pure-menu-item title="All series"><a class=pure-menu-link href=/series/>Series</a></li><li class=pure-menu-item title="All categories"><a class=pure-menu-link href=/categories/>Categories</a></li><li class=pure-menu-item title="About me"><a class=pure-menu-link href=/about/>About</a></li></ul></div></div></div><div><div><h2 class=post-title><a href=/posts/2020/11/go/build-constraints/>Go条件编译</a></h2><div class=post-meta><span>Date</span> [
<time datetime=2020-11-13T18:39:55+08:00>2020-11-13</time>
]
<span>Categories</span> [
<a href=/categories/go>go</a>
]
<span>Series</span> [
<a href=/series></a>]
<span>Tags</span> [
<a href=/tags/go>go</a>
]</div></div><div><p>Go是支持条件编译，可能很多人都不知道。Go通过在行注释的前面编写如下代码来实现条件编译。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// +build
</span></code></pre></div><p>条件编译的指令可能出现在任何源代码中，不止是*.go文件，可能是go汇编文件。无论是何种源文件，条件编译指令一定都出现在文件的顶部，并且在空行或者其他行注释之前。所以条件编译指令也必须在package语句之前。</p><hr><h1 id=条件编译规则>条件编译规则</h1><ol><li><p>可以将 // +build 后面的内容当成一个表达式。当表达式返回true时，当前文件参与编译，反之不参与编译。</p></li><li><p>多个片段之间的空格表示它们之间是OR的关系。如下，表示GOOS值是linux或者darwin时，本文件参与编译。</p></li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// +build linux darwin
</span></code></pre></div><ol start=3><li>多个片段之间的,表示它们之间是AND的关系。如下，表示GOOS值是linux且是amd64架构时，本文件参与编译。</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// +build linux,amd64
</span></code></pre></div><ol start=4><li>以!xxx开头的片段表示当tag xxx设置时，当前文件不参与编译。如下，表示GOOS值是linux时，本文件不参与编译。</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// +build !linux
</span></code></pre></div><ol start=5><li>单文件包含多个条件编译指令时，它们是AND的关系。如下，表示GOOS值是linux且是amd64架构时，本文件参与编译。</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// +build linux
</span><span style=color:#75715e>// +build amd64
</span></code></pre></div><ol start=6><li><p>一些内建的关键字。</p><ol><li><code>GOOS</code>的值，目标操作系统，如linux,darwin。</li><li><code>GOARCH</code>的值，目标架构，如amd64。</li><li>编译器，<code>gc</code> 或者 <code>gccgo</code>。</li><li><code>cgo</code> 如果cgo支持，编译。</li><li><code>gox.x</code> 只在特定go版本进行编译，不支持beta or minor版本号的条件编译。</li><li><code>go build</code> 命令的其他tag。</li></ol></li><li><p>文件名实现条件编译。条件编译支持以下三种格式（<code>源码文件名去除类型后缀和_test后缀后</code>）：</p><ol><li><code>*_GOOS</code> GOOS值与文件名中的GOOS一致时参与编译。</li><li><code>*_GOARCH</code> GOARCH值与文件名中的GOARCH一致时参与编译。</li><li><code>*_GOOS_GOARCH</code> GOARCH,GOOS值与文件名中的GOARCH,GOOS一致时参与编译。</li></ol><p>如 <code>source_windows_amd64.go</code> 该文件只在<code>windows</code>系统的<code>amd64</code>架构下进行编译。</p></li></ol><h1 id=示例>示例</h1><p>示例的文件目录:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ tree .
$ .
$ ├── etcd.go
$ ├── go.mod
$ ├── main.go
$ └── redis.go
</code></pre></div><p><code>etcd.go</code> 当tags中出现etcd字符时，不参与编译。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// +build !etcd
</span><span style=color:#75715e></span>
<span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#a6e22e>fun</span> <span style=color:#a6e22e>init</span>() {
  println(<span style=color:#e6db74>&#34;etcd init&#34;</span>)
}
</code></pre></div><p><code>redis.go</code> 当tags中出现redis字符时，不参与编译。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// +build !redis
</span><span style=color:#75715e></span>
<span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#a6e22e>fun</span> <span style=color:#a6e22e>init</span>() {
  println(<span style=color:#e6db74>&#34;redis redis&#34;</span>)
}
</code></pre></div><p><code>main.go</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
  println(<span style=color:#e6db74>&#34;hell world!&#34;</span>)
}
</code></pre></div><p>下面我们来看看效果吧！</p><ol><li>直接编译，不执行条件编译</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ go run .
$ etcd init
$ redis init
$ hell world!
</code></pre></div><p>可以看到，etcd.go,redis.go,main.go都被编译了。</p><ol><li>不编译redis.go文件</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ go run -tags redis .   <span style=color:#75715e># 我们使用 `-tags` 来设置编译条件。</span>
$ etcd init
$ hell world!
</code></pre></div><p>这时候我们看到，只有etcd.go和main.go被编译了，redis.go中的init方法没有被执行。</p><ol start=3><li>不编译etcd.go文件</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ go run -tags etcd .   <span style=color:#75715e># 我们使用 `-tags` 来设置编译条件。</span>
$ redis init
$ hell world!
</code></pre></div><p>这时候我们看到，只有redis.go和main.go被编译了，main.go中的init方法没有被执行。</p><ol start=4><li>不编译etcd.go和redis.go文件</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ go run -tags etcd,redis .   <span style=color:#75715e># 我们使用 `-tags` 来设置编译条件。</span>
$ hell world!
</code></pre></div><p>这时候我们看到，只有main.go文件中的main函数被执行了，其他文件中的init方法均没哟被执行。</p><h1 id=总结>总结</h1><p>在go的源代码中条件编译使用的非常广泛。比如某些功能在不同操作系统的实现不一样，这时候我们就需要针对不同操作系统分别编写代码，但这些代码都在一个目录中，如果没有条件编译将无法编译成功。又或者我们的配置信息可能来自Redis,Etcd,ZooKeeper等不同的配置源，但在运行时我们只用到Etcd，这时候我们可以对代码进行拆分并编写条件编译指令，在编译时只编译Etcd数据源的代码以减小不必要的依赖。</p><p>有些靠编写代码没法控制事情，通过条件编译也许可以帮助你，总之掌握条件编译可以帮助我们更好得完成开发工作，甚至实现一些普通程序员无法理解的“黑科技”。</p></div></div><div class=post-divider><div><h2 class=post-title><a href=/posts/2020/11/go-src/sync/atomic/>Go源码解析之atomic</a></h2><div class=post-meta><span>Date</span> [
<time datetime=2020-11-08T20:16:35+08:00>2020-11-08</time>
]
<span>Categories</span> [
<a href=/categories/go>go</a>
]
<span>Series</span> [
<a href=/series/go%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90>Go源码解析</a>
]
<span>Tags</span> [
<a href=/tags/go>go</a>
<a href=/tags/sync>sync</a>
<a href=/tags/atomic>atomic</a>
]</div></div><div><p>今天我们来聊聊go的<strong>atomic</strong> pkg，<strong>atomic</strong>是go并发编程中最为基础的库。如果说它是go并发编程的基石一点也不为过，像标准库中大家使用率非常高的<strong>Mutex</strong>, <strong>RWMutex</strong>,<strong>WaitGroup</strong>,<strong>Once</strong>等的实现都依赖于<strong>atomic</strong>。</p><h1 id=atomic简介>Atomic简介</h1><p><strong>atomic</strong>提供一系列用于实现同步功能的、底层的，原子的方法：</p><ol><li><strong>AddT</strong> 系列将增量增加到源值上，并返回新值。</li><li><strong>CompareAndSwapT</strong> 系列比较两个变量的值，并进行交换。</li><li><strong>SwapT</strong>系列交换值，并返回旧值。</li><li><strong>LoadT</strong> 系列获取值。</li><li><strong>StoreT</strong> 系列更新值。</li><li><strong>Value</strong> 存储器，支持Load,Store。</li></ol><p>这些方法是原子操作，不会被CPU中断，也就说在多个goroutine之间访问是安全的。</p><p>比如<strong>CompareAndSwapT</strong>方法，其实它包含多个步骤，在CPU执行时也是多个命令完成这个功能。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>addr</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>old</span> {
	<span style=color:#f92672>*</span><span style=color:#a6e22e>addr</span> = <span style=color:#a6e22e>new</span>
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
}
<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</code></pre></div><p>那么go是如何让这些方法变成了原子操作呢？我们接着往下看。</p><h1 id=刨根问底>刨根问底</h1><p>为了搞清楚<strong>atomic</strong>到底是如何工作的，我们以<strong>CompareAndSwapInt32</strong>为例来分析。我打开了<a href=https://github.com/golang/go/tree/master/src/sync/atomic>atomic</a>的源代码。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>asm.s
atomic_test.go
doc.go
example_test.go
race.s
value.go
value_test.go
</code></pre></div><p>包内的文件数并不多，打开第一个<strong>asm.s</strong>，我们就看到非常重要的内容。</p><p>这是一个go汇编文件，我摘取了部分重要的内容。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>// +build !race

#include &#34;textflag.h&#34;

TEXT ·SwapInt32(SB),NOSPLIT,$0
	JMP	runtime∕internal∕atomic·Xchg(SB)

// ...略去...

TEXT ·CompareAndSwapInt32(SB),NOSPLIT,$0
	JMP	runtime∕internal∕atomic·Cas(SB)	

// ...略去...

TEXT ·AddInt32(SB),NOSPLIT,$0
	JMP	runtime∕internal∕atomic·Xadd(SB)
	
// ...略去...
	
TEXT ·LoadInt32(SB),NOSPLIT,$0
	JMP	runtime∕internal∕atomic·Load(SB)	

// ...略去...

TEXT ·StoreInt32(SB),NOSPLIT,$0
	JMP	runtime∕internal∕atomic·Store(SB)	
</code></pre></div><p><code>// +build !race</code> 这是go的条件编译，表示race时不编译，不是本文重点，欲知更多请查看<a href=https://golang.org/cmd/go/#hdr-Build_constraints>Go build constraints</a>。<code>#include "textflag.h"</code> 引用头文件，定义了一些宏。</p><p>下面来到我们的重点 <code>TEXT ·CompareAndSwapInt32(SB),NOSPLIT,$0</code> 定义了CompareAndSwapInt32函数，可以看到它并没有什么逻辑，直接跳转去了<code>runtime∕internal∕atomic·Cas</code>。那么我们就跟过去。</p><p>我们查看amd64版本代码<a href=https://github.com/golang/go/blob/master/src/runtime/internal/atomic/stubs.go#L12>stubs.go</a>，看到了函数的声明*<em>func Cas(ptr <em>uint32, old, new uint32) bool</em></em>，但是并没有函数体。Go还可以这么玩？函数体去哪里了？</p><p>经过一番侦查，在<a href=https://github.com/golang/go/blob/master/src/runtime/internal/atomic/asm_amd64.s#L17>asm_amd64.s</a>中发现了汇编实现的函数体。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>// bool Cas(int32 *val, int32 old, int32 new)
// Atomically:
//	if(*val == old){
//		*val = new;
//		return 1;
//	} else
//		return 0;
TEXT runtime∕internal∕atomic·Cas(SB),NOSPLIT,$0-17
	MOVQ	ptr+0(FP), BX
	MOVL	old+8(FP), AX
	MOVL	new+12(FP), CX
	LOCK
	CMPXCHGL	CX, 0(BX)
	SETEQ	ret+16(FP)
	RET
</code></pre></div><p>第一行MOVQ ptr到BX寄存器。<strong>FP</strong> 是go汇编定义的伪寄存器，伪FP寄存器对应的是函数的帧指针，一般用来访问函数的参数和返回值。Go汇编是基于<a href=https://9p.io/sys/doc/asm.html>plan9</a>的，MOV的方向和我们常规学习到的相反。</p><p>第二行MOVL old值到AX寄存器。</p><p>第三行MOVL new值到CX寄存器。</p><p>第四行<strong>LOCK</strong>，这个命令非常陌生。经过一番资料查询了解到<a href=https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf>Intel® 64 and IA-32 Architectures Software Developer’s Manual</a>，LOCK能将后续的指令变成原子操作，那么后续的<strong>CMPXCHGL</strong>也将被原子化。</p><p>第五行CMPXCHGL CX, 0(BX)，将BX的值(ptr)与CX的值(new)比较。如果相等，CX更新到ptr，否者BX更新到AX。</p><p>第六行SETEQ ret+16(FP)，如果ZF标志位为0，设置1到返回值(FP偏移16位)，否者设置0。</p><p>第七行RET 函数返回。</p><hr><p>这里最重要的是<strong>LOCK</strong>与<strong>CMPXCHGL</strong>两个命令，两条命令组合完成了Cas操作。这是CPU支持的原子操作。后续补充CPU这块关于LOCK的一些介绍。</p><hr><p>atomic中其他方法实现原子操作的方案基本与此一致，在此就不赘述了，有兴趣的童鞋可以自己研究一下。</p><h1 id=参考文档>参考文档：</h1><ol><li><a href=https://wweir.cc/post/%E6%8E%A2%E7%B4%A2-golang-%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E8%AF%AD/>探索 Golang 一致性原语</a></li></ol></div></div><div class=post-divider><div><h2 class=post-title><a href=/posts/2020/10/factory/>Go设计模式之Factory</a></h2><div class=post-meta><span>Date</span> [
<time datetime=2020-10-14T20:30:39+08:00>2020-10-14</time>
]
<span>Categories</span> [
<a href=/categories/go>go</a>
]
<span>Series</span> [
<a href=/series/go%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f>Go设计模式</a>
]
<span>Tags</span> [
<a href=/tags/go>go</a>
<a href=/tags/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f>设计模式</a>
]</div></div><div><h1 id=factory---工厂模式>Factory - 工厂模式</h1><p>工厂模式在Go中使用的非常广泛，比如常用于数据的读写模块。假设我们需要从某种介质中读取数据，并将更新后的结果保存到该介质中。考虑到以后可能更换为其他类型的介质，为了避免日后更换介质而大面积变更代码，我们就会用到本模式。</p><h1 id=实现>实现</h1><h2 id=1定义工厂方法所创建对象的接口>1.定义工厂方法所创建对象的接口</h2><p>假设我们的存储模块只有<strong>Read</strong>和<strong>Write</strong>两个功能，我们需要先定义存储器<strong>inteface</strong>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>store</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;io&#34;</span>

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Store</span> <span style=color:#66d9ef>interface</span> {
    <span style=color:#a6e22e>Read</span>(<span style=color:#66d9ef>string</span>) ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>)
    <span style=color:#a6e22e>Save</span>(<span style=color:#66d9ef>string</span>, []<span style=color:#66d9ef>byte</span>) (<span style=color:#66d9ef>error</span>)
}
</code></pre></div><h2 id=2实现对象接口>2.实现对象接口</h2><p>假设我们需要将Redis或磁盘作为存储介质，我们需要分别实现Redis与磁盘的存储功能。</p><h3 id=filesystem>FileSystem</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>pacakge</span> <span style=color:#a6e22e>store</span>

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>FileStore</span> <span style=color:#66d9ef>struct</span>{
  <span style=color:#75715e>/*your codes*/</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>store</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>FileStore</span>) <span style=color:#a6e22e>Read</span>(<span style=color:#66d9ef>string</span>) ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>) {
  <span style=color:#75715e>/*your codes*/</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>store</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>FileStore</span>) <span style=color:#a6e22e>Save</span>(<span style=color:#66d9ef>string</span>, []<span style=color:#66d9ef>byte</span>) (<span style=color:#66d9ef>error</span>) {
  <span style=color:#75715e>/*your codes*/</span>
}

<span style=color:#75715e>// 注意这里要返回 Store 接口，而不是FileStore的指针。
</span><span style=color:#75715e>// 可以保证工厂方法只能调用到对象接口方法，避免封装被破坏。
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newFileStore</span>() <span style=color:#a6e22e>Store</span> {
  <span style=color:#75715e>/*your codes*/</span>
}
</code></pre></div><h3 id=redis>Redis</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>pacakge</span> <span style=color:#a6e22e>store</span>

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>RedisStore</span> <span style=color:#66d9ef>struct</span>{
  <span style=color:#75715e>/*your codes*/</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>store</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RedisStore</span>) <span style=color:#a6e22e>Read</span>(<span style=color:#66d9ef>string</span>) ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>) {
  <span style=color:#75715e>/*your codes*/</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>store</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RedisStore</span>) <span style=color:#a6e22e>Save</span>(<span style=color:#66d9ef>string</span>, []<span style=color:#66d9ef>byte</span>) (<span style=color:#66d9ef>error</span>) {
  <span style=color:#75715e>/*your codes*/</span>
}

<span style=color:#75715e>// 注意这里要返回 Store 接口，而不是RedisStore的指针。
</span><span style=color:#75715e>// 可以保证工厂方法只能调用到对象接口方法，避免封装被破坏。
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newRedisStore</span>() <span style=color:#a6e22e>Store</span> {
  <span style=color:#75715e>/*your codes*/</span>
}
</code></pre></div><h2 id=3实现工厂方法>3.实现工厂方法</h2><p>工厂方法是暴露给模块外部使用的，用于创建实例的方法。我们需要将各种类型<strong>Store</strong>实例的创建过程封装到该方法里面，避免暴露给外部模块。由工厂方法统一提供创建功能。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>pacakge</span> <span style=color:#a6e22e>store</span>

<span style=color:#66d9ef>type</span> (
  <span style=color:#a6e22e>StoreType</span> <span style=color:#66d9ef>int</span>
)

<span style=color:#66d9ef>const</span> (
  <span style=color:#a6e22e>File</span> <span style=color:#a6e22e>StorageType</span> = <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>iota</span>
  <span style=color:#a6e22e>Redis</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewStore</span>(<span style=color:#a6e22e>storeType</span> <span style=color:#a6e22e>StoreType</span>) <span style=color:#a6e22e>Store</span> {
  <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>storeType</span> {
    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>File</span>:
      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newFileStore</span>()
    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Redis</span>:
      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newRedisStore</span>()
    <span style=color:#66d9ef>default</span>:
      panic(<span style=color:#e6db74>&#34;尚未支持的存储类型！&#34;</span>)
  }
}
</code></pre></div><h1 id=使用>使用</h1><p>假设我们需要使用<strong>Redis</strong>作为存储介质，我们只需要在工厂方法中传入<strong>store.Redis</strong>参数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
  <span style=color:#e6db74>&#34;fmt&#34;</span>

  <span style=color:#e6db74>&#34;xxxx/store&#34;</span> <span style=color:#75715e>// 你的模块地址
</span><span style=color:#75715e></span>)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
  <span style=color:#a6e22e>st</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>store</span>.<span style=color:#a6e22e>NewStore</span>(<span style=color:#a6e22e>store</span>.<span style=color:#a6e22e>Redis</span>)

  <span style=color:#75715e>// 读取数据
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>st</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#e6db74>&#34;/foo&#34;</span>)
  <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>data</span>)

  <span style=color:#75715e>// 保存数据
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>st</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#e6db74>&#34;/foo&#34;</span>, <span style=color:#a6e22e>data</span>)
  <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
}
</code></pre></div><p>如果现在我们想更换介质为文件系统，我们只需要更换工厂方法中传入的参数为<strong>store.File</strong>即可完成介质更换。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 其他代码不变
</span><span style=color:#75715e></span>
<span style=color:#75715e>// 工厂方法的参数更改为store.File即可。
</span><span style=color:#75715e></span><span style=color:#a6e22e>st</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>store</span>.<span style=color:#a6e22e>NewStore</span>(<span style=color:#a6e22e>store</span>.<span style=color:#a6e22e>File</span>)

<span style=color:#75715e>// 其他代码不变
</span></code></pre></div></div></div><div class=post-divider><div><h2 class=post-title><a href=/posts/2020/09/go-patterns/singleton/>Go设计模式之Singleton</a></h2><div class=post-meta><span>Date</span> [
<time datetime=2020-09-30T22:40:58+08:00>2020-09-30</time>
]
<span>Categories</span> [
<a href=/categories/go>go</a>
]
<span>Series</span> [
<a href=/series/go%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f>Go设计模式</a>
]
<span>Tags</span> [
<a href=/tags/go>go</a>
<a href=/tags/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f>设计模式</a>
]</div></div><div><h1 id=singleton---单例模式>Singleton - 单例模式</h1><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h1 id=实现>实现</h1><h2 id=饿汉式>饿汉式</h2><p>饿汉式单例是指在方法调用前，实例就已经创建好了。</p><p>按照<strong>用法</strong>使用，可以看到控制台输出10次单例的内存地址是一样的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;sync&#34;</span>
	<span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>type</span> (
	<span style=color:#a6e22e>server</span> <span style=color:#66d9ef>struct</span> {
		<span style=color:#a6e22e>port</span> <span style=color:#66d9ef>int</span>
	}
)

<span style=color:#66d9ef>var</span> (
	<span style=color:#a6e22e>instance</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>server</span>{}
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getServerSingleton</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>server</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>instance</span>
}

<span style=color:#75715e>/*
</span><span style=color:#75715e>server ptr: 0x1182ec0
</span><span style=color:#75715e>server ptr: 0x1182ec0
</span><span style=color:#75715e>server ptr: 0x1182ec0
</span><span style=color:#75715e>server ptr: 0x1182ec0
</span><span style=color:#75715e>server ptr: 0x1182ec0
</span><span style=color:#75715e>server ptr: 0x1182ec0
</span><span style=color:#75715e>server ptr: 0x1182ec0
</span><span style=color:#75715e>server ptr: 0x1182ec0
</span><span style=color:#75715e>server ptr: 0x1182ec0
</span><span style=color:#75715e>server ptr: 0x1182ec0
</span><span style=color:#75715e>*/</span>
</code></pre></div><h2 id=懒汉式---非goroutine安全>懒汉式 - 非Goroutine安全</h2><p>懒汉式单例是指在方法调用获取实例时才创建实例，因为相对饿汉式显得“不急迫”，所以被叫做“懒汉模式”。</p><p>按照<strong>用法</strong>使用，可以看到控制台输出10次单例的内存地址并不完全一样。</p><p>一共有以下3个指针：</p><ul><li>0xc0000c4000</li><li>0xc0000ca000</li><li>0xc0000c2000</li></ul><p>可见此懒汉模式不支持在实例未初始化时高并发调用。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>type</span> (
	<span style=color:#a6e22e>server</span> <span style=color:#66d9ef>struct</span> {
		<span style=color:#a6e22e>port</span> <span style=color:#66d9ef>int</span>
	}
)

<span style=color:#66d9ef>var</span> (
	<span style=color:#a6e22e>instance</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>server</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getServerSingleton</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>server</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>instance</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>instance</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>server</span>{}
	}

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>instance</span>
}

<span style=color:#75715e>/*
</span><span style=color:#75715e>server ptr: 0xc0000c4000
</span><span style=color:#75715e>server ptr: 0xc0000ca000
</span><span style=color:#75715e>server ptr: 0xc0000c4000
</span><span style=color:#75715e>server ptr: 0xc0000c2000
</span><span style=color:#75715e>server ptr: 0xc0000c2000
</span><span style=color:#75715e>server ptr: 0xc0000ca000
</span><span style=color:#75715e>server ptr: 0xc0000ca000
</span><span style=color:#75715e>server ptr: 0xc0000ca000
</span><span style=color:#75715e>server ptr: 0xc0000ca000
</span><span style=color:#75715e>server ptr: 0xc0000ca000
</span><span style=color:#75715e>*/</span>
</code></pre></div><h2 id=懒汉式---goroutine安全>懒汉式 - Goroutine安全</h2><p>我们可以利用golang sync包提供的Once结构体来解决Goroutine安全问题。Once提供了在应用程序生命周期中仅会被调用一次的解决方案。我们将实例的生成过程使用Once保护起来，那么即可以做到单例。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;sync&#34;</span>
)

<span style=color:#66d9ef>type</span> (
	<span style=color:#a6e22e>server</span> <span style=color:#66d9ef>struct</span>{}
)

<span style=color:#66d9ef>var</span> (
	<span style=color:#a6e22e>instance</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>server</span>
	<span style=color:#a6e22e>once</span>     <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Once</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getServerSingleton</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>server</span> {
	<span style=color:#a6e22e>once</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#66d9ef>func</span>() {
		<span style=color:#a6e22e>instance</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>server</span>{}
	})

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>instance</span>
}

<span style=color:#75715e>/*
</span><span style=color:#75715e>server ptr: 0x1182f88
</span><span style=color:#75715e>server ptr: 0x1182f88
</span><span style=color:#75715e>server ptr: 0x1182f88
</span><span style=color:#75715e>server ptr: 0x1182f88
</span><span style=color:#75715e>server ptr: 0x1182f88
</span><span style=color:#75715e>server ptr: 0x1182f88
</span><span style=color:#75715e>server ptr: 0x1182f88
</span><span style=color:#75715e>server ptr: 0x1182f88
</span><span style=color:#75715e>server ptr: 0x1182f88
</span><span style=color:#75715e>server ptr: 0x1182f88
</span><span style=color:#75715e>*/</span>
</code></pre></div><h1 id=用法>用法</h1><p>模拟10个并发请求获取单例。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>wg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>{}

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>index</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>index</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>index</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)

		<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
			<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>100</span>)

			<span style=color:#a6e22e>server</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getServerSingleton</span>()
			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;server ptr: %p \n&#34;</span>, <span style=color:#a6e22e>server</span>)

			<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
		}()
	}

	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
}
</code></pre></div></div></div><div class=post-divider><div><h2 class=post-title><a href=/posts/2020/09/godoc/>Go工具链之godoc指南</a></h2><div class=post-meta><span>Date</span> [
<time datetime=2020-09-27T21:30:30+08:00>2020-09-27</time>
]
<span>Categories</span> [
<a href=/categories/go>go</a>
]
<span>Series</span> [
<a href=/series/go%e5%b7%a5%e5%85%b7%e9%93%be>Go工具链</a>
]
<span>Tags</span> [
<a href=/tags/go>go</a>
<a href=/tags/godoc>godoc</a>
]</div></div><div><p>在写<a href=https://github.com/boxgo/box>boxgo</a>的过程中，想要生成漂亮的godoc，发现不太熟悉godoc的用法，所以就有了本篇文章，记录一下。</p><p>Go团队非常重视文档，文档对项目的可阅读性、可维护性起到重要作用，所以写好文档变得非常重要。Go团队提供了<code>godoc</code>工具以帮助开发者方便、准确，容易的生成项目文档。<code>godoc</code>解析Go源代码（包括注释），并以HTML或纯文本格式生成文档。</p><h1 id=生成文档>生成文档</h1><p>提取规则：</p><ol><li><p>类型、变量、常量、函数，包都可以通过在声明的前面写注释的方法生成文档（中间不要有空行）。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Package doc 包注释  --- good
</span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>doc</span>
   
<span style=color:#66d9ef>type</span> (
  <span style=color:#75715e>// UserType 类型注释  --- good
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>UserType</span> <span style=color:#66d9ef>string</span>
)
   
<span style=color:#66d9ef>var</span> (
  <span style=color:#75715e>// userType 变量注释  --- good
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>userType</span> <span style=color:#a6e22e>UserType</span>
)
   
<span style=color:#66d9ef>const</span> (
  <span style=color:#75715e>// Zero 常量注释  --- good
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>Zero</span> = <span style=color:#ae81ff>0</span>
)
   
<span style=color:#75715e>// Test 函数注释  --- good
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Test</span>() {
   
}
   
   
<span style=color:#75715e>// Test1 函数注释  --- bad（不要有空行）
</span><span style=color:#75715e></span>   
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Test1</span>() {
   
}
</code></pre></div></li><li><p>注释开头的字母需要与被注释的元素名称保持一致（<code>包</code>除外）。如函数<code>Fprint</code>注释开头的第一个字母也是<code>Fprint</code>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Fprint formats using the default formats for its operands and writes to w.
</span><span style=color:#75715e>// Spaces are added between operands when neither is a string.
</span><span style=color:#75715e>// It returns the number of bytes written and any write error encountered.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Writer</span>, <span style=color:#a6e22e>a</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>interface</span>{}) (<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
  <span style=color:#75715e>//
</span><span style=color:#75715e></span>}
</code></pre></div></li><li><p><code>doc.go</code> - 包注释比较多的话也可以使用单独的<code>doc.go</code>来编写文档。参考<a href=https://golang.org/src/encoding/gob/doc.go>gob package&rsquo;s doc</a>。</p></li><li><p><code>BUG(who)</code> - 注释与被注释主体之间通常不能有空行或者空注释，但是<code>BUG(who)</code>是一个例外，<code>BUG</code>将在godoc的文档中展示。参考：<a href=https://golang.org/pkg/bytes/#pkg-note-BUG>bytes package</a>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin
</span><span style=color:#75715e>// words mapped to their title case.
</span><span style=color:#75715e>//
</span><span style=color:#75715e>// BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Title</span>(<span style=color:#a6e22e>s</span> []<span style=color:#66d9ef>byte</span>) []<span style=color:#66d9ef>byte</span> {
</code></pre></div></li><li><p><code>Deprecated</code> - 可以描述struct field, function, type, variable, const甚至是package，表示被弃用，后续不再使用，但必须保持兼容性。</p></li><li><p>多个相邻的注释行，生成文档时被视为一个段落，如果想要生成多个段落，请留空行。</p></li><li><p>预格式文本需要相对上下文的注释有缩进。</p></li><li><p>URL无需标记，文档中也会被转换成URL。</p></li></ol><h1 id=查看文档>查看文档</h1><p>几行代码带你查看你项目的godoc。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># 进入你的项目源代码目录</span>
cd $your_project_dir

<span style=color:#75715e># 为项目建立软连接，因为godoc目前对go mod支持的不是很好，所以需要将项目软链到GOPATH内。如果你的项目在GOPATH目录中，跳过此步骤。</span>
ln -s $your_project_dir $GOPATH/src/$your_module_path

<span style=color:#75715e># 启动godoc服务</span>
godoc -http<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;:6060&#34;</span>

<span style=color:#75715e># mac下查看文档。其他操作系统请打开浏览器访问。</span>
open http://127.0.0.1:6060/pkg/$your_module_path
</code></pre></div><p>效果图</p><p><img src=/posts/godoc/image-20200928161749381.png alt=image-20200928161749381></p><h1 id=参考文档>参考文档</h1><p><a href=https://pkg.go.dev/golang.org/x/tools/cmd/godoc>godoc command</a></p><p><a href=https://blog.golang.org/godoc>godoc blog</a></p></div></div><div class=pagination-content><div class="pure-menu pure-menu-horizontal"><ul class=pure-menu-list><li class="pure-menu-item pure-menu-disabled">Pages</li><li class="pure-menu-item pure-menu-selected"><a href=/ class=pure-menu-link>First</a></li><li class="pure-menu-item pure-menu-selected"><a href=/ class=pure-menu-link>Last</a></li></ul></div></div><div class=footer><div class="pure-menu pure-menu-horizontal"><ul class=pure-menu-list><li class=pure-menu-item title="My repository"><a class=pure-menu-link href=https://github.com/amazing-gao>GitHub</a></li><li class=pure-menu-item title="RSS Feed"><a href=/index.xml class=pure-menu-link>RSS</a></li><li class="pure-menu-item fix-cursor-pointer" title="Go to top"><a class=pure-menu-link id=btn-gototop><span class=fix-placement-up>&#8679;&#xfe0e;</span></a></li></ul></div><div class="pure-menu pure-menu-horizontal"><ul class=pure-menu-list><li class="pure-menu-item pure-menu-disabled">&copy; 2020 &mdash; Amazing-Gao — All rights reserved.</li></ul></div></div></div><div class="pure-u-1-24 pure-u-md-5-24"></div></div></body></html>