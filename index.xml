<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Amazing-Gao 实在是高</title><link>/</link><description>Recent content on Amazing-Gao 实在是高</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>amazing.gao@qq.com (AmazingGao)</managingEditor><webMaster>amazing.gao@qq.com (AmazingGao)</webMaster><copyright>Amazing-Gao — All rights reserved.</copyright><lastBuildDate>Thu, 12 Aug 2021 17:16:02 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>基于信创的互金应用探索与实践</title><link>/posts/2021/08/sahre/cn-it/</link><pubDate>Thu, 12 Aug 2021 17:16:02 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2021/08/sahre/cn-it/</guid><description>信创是什么？ 信创二字来源于“信息技术应用创新工作委员会”。2016年3月4日工委会成立，是由从事信息技术软硬件关键技术研究、应用和服务的企事业单位发起建立的非营利性社会组织。
信创产业，即信息技术应用创新产业。信创产业推进的背景在于，过去中国IT底层标准、架构、产品、生态大多数都由国外IT商业公司来制定，由此存在诸多的底层技术、信息安全、数据保存方式被限制的风险。
全球IT生态格局将由过去的“一极”向未来的“两极”演变，中国要逐步建立基于自己的IT底层架构和标准。基于自有IT底层架构和标准建立起来的IT产业生态便是信创产业的主要内涵。
跟我们有什么关系？ 根据中国证监会科技监管局《关于建立信息技术应用创新工作一把手责任制的通知》（[2021]221号文）要求，公司决定成立信创工作领导小组和执行小组，xx、xx有幸被选中作为首批的试点项目。
我们要做什么？ 简单来说，我们的远期目标是实现全面国产化，说实话从我个人来看的话目标的难度非常大，非常具有挑战性。我们的短期目标是什么呢？实现应用程序的国产CPU服务器和国产数据库化。
国产CPU服务器 国产CPU服务器化，对应用侧来说就是将程序部署于国产CPU的服务器之上，目前我们互联网金融的应用程序均部署于公司的微服务平台 — Eagle。
国产服务器硬件层面由 Eagle 与公司基础运维组 统一采购、部署、管理，对于应用侧来说只需将应用程序发布到相应的信创集群即可，那么 Eagle 方面目前提供了哪些方案呢？
操作系统 操作系统研发单位 CPU型号 CPU研发单位 CPU指令集体系 CPU架构来源 是否就绪 银河麒麟 V10 麒麟软件 鲲鹏920 华为 ARM 指令集授权 是（集群标签armcs1） 银河麒麟 V10 麒麟软件 飞腾 天津飞腾 ARM 指令集授权 否 银河麒麟 V10 麒麟软件 海光 天津海光 x86（AMD） IP授权 否 Eagle 主推“麒麟+鲲鹏“方案；考虑到服务器交付风险，增加”麒麟+飞腾“备选方案；考虑到业务系统向 ARM 平台迁移改造的适配风险，增加”麒麟+海关“备选方案。
信创主推和备选的是自主化程度较高、基于 ARM 指令集体系方案，对于应用侧来说也是改造最多的，所以这是我们重点关注的方案。</description></item><item><title>算法（第4版）</title><link>/books/algorithms4/</link><pubDate>Thu, 04 Mar 2021 22:24:19 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/books/algorithms4/</guid><description>第1章 基础 本书对基础这块笔墨非常多，第1章就有150页之多，简洁利落的介绍了本书所涉及Java程序的基础、数据抽象，基本数据结构。同时，也讲解了分析和比较算法的基本原则和方法。本书作者非常用心，适合初学者或者基础薄弱的童鞋入门。
基础编程模型 本书使用Java语言来实现算法，这么做的原因如下：
程序是对算法精确、优雅和完全的描述 可以通过运行程序来学习算法的各种性质 可以在应用程序中直接使用这些算法 相比使用自然语言描述这些优势是重要而巨大的。但使用某一具体的语言也存在缺点，这会使分离算法的思想和实现细节变得困难，所以书中只使用了Java的部分子集功能。
原始数据类型与表达式 Java程序的基本组成 原始数据类型 int, double, boolean, char等 标识符 a, abc等 变量 任意标识符 运算符 + - * / 字面量 int 1, 0, -42等 double 2.0, 1.0e-15等 boolean true, false ... 表达式 int n1+n2/2 double 1.0e-15 * x boolean x &amp;lt;=y 本书常用的原始数据类型 整型 int，及其算术运算符 双精度实数 double，及其算术运算符 布尔 boolean，及其逻辑操作 字符串 string 优先级 算术运算：</description></item><item><title>Go工具链之compile初探</title><link>/posts/2021/02/go/compile/</link><pubDate>Wed, 24 Feb 2021 23:48:08 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2021/02/go/compile/</guid><description>在阅读 Go 源代码的过程，可以看到大量形如 //go:xxx 的注释，虽然很容易猜测到肯定是和编译相关的，但并不清晰，于是就想深入了解一下。
在日常编译可执行文件的过程中，我想大家使用最多的毫无疑问是 go build 。只需一行命令即可将庞大且复杂的项目源代码编译成可执行文件，Go 把复杂的编译过程设计的非常简单、友好。 但是其实 Go 和 C/C++ 一样，也分为 compile 和 link 两个过程，今天我们要讲的就是 compile 过程。
自举 Go 在 1.5 之前使用 C 实现编译器，在 1.5 实现了自举，也就是说 Go 的编译器是使用 Go 语言本身去实现的。 自举对编程语言来说是个里程碑，实现自举包括但不限于以下的好处：
语言通过自我编译、自我迭代，达到本身语言的真正成熟稳定 对编译器后端的优化不仅会优化以后所有编译出来的其它程序的效率，也会优化编译器本身的效率 使开发编译器的环境和使用这门语言开发的其它程序一致 摆脱其它语言的依赖和自我迭代 编译命令 Go 程序源码的编译可以通过以下命令行执行 go tool compile [flags] file...，简单来说该命令可以将同一个 package 的多个文件编译成一个 .o 文件，多个 .o 文件又可以被链接成一个可执行文件。
下面我们以一个简单的 hello world 程序来举例。
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 fmt.Println(&amp;#34;hello world&amp;#34;) 7} 执行编译命令，可以得到 main.</description></item><item><title>Books</title><link>/booklist/</link><pubDate>Sat, 06 Feb 2021 16:47:59 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/booklist/</guid><description>正在阅读 书名 开始/结束 《图解TCP/IP》 2021-07/? 《投资最重要的事》 2021-09-15/? 《MySQL实战45讲》 2021-02/? 《世界简史》 2020-12/? 计划阅读 书名 开始/结束 《Go语言设计与实现》 《Redis设计与实现》 《中国通史》 《卡耐基：魅力口才与演讲艺术》 《领导者习惯 - 卓越管理的22个必备技能》 《Go语言原本》 完成阅读 书名 开始/结束 《算法》第4版 2021-02/2021-08 《左耳听风》 2021-01/2021-04 《深入理解计算机系统》 2020-01/2021-02 《洛克菲勒自传》 2020 《特斯拉自传》 2020 《设计模式》 2019 《微服务设计》 2019 《SQL必知必会》 2019</description></item><item><title>Rancher初体验</title><link>/posts/2021/02/rancher/quick-start/</link><pubDate>Sat, 06 Feb 2021 16:47:59 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2021/02/rancher/quick-start/</guid><description>Kubernetes 是什么？ 在技术圈大家对大名鼎鼎的 Kubernetes（别名k8s）肯定都是耳熟能详，无论过去、现在和未来，它都将对世界产生非常深远的积极影响。
在此借用官方介绍：
Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。 名称 Kubernetes 源于希腊语，意为“舵手”或“飞行员”。Google 在 2014 年开源了 Kubernetes 项目。 Kubernetes 建立在 Google 在大规模运行生产工作负载方面拥有十几年的经验 的基础上，结合了社区中最好的想法和实践。 Rancher 是什么？ 在此还是借用官方介绍：
Rancher 是为使用容器的公司打造的容器管理平台。 Rancher 简化了使用 Kubernetes 的流程，开发者可以随处运行 Kubernetes（Run Kubernetes Everywhere）， 满足 IT 需求规范，赋能 DevOps 团队。 简而言之 Rancher 基于 k8s 平台，旨在打造一个更易用、更全面、更安全的容器管理平台。Rancher 提供了一系列企业级服务亟需的开箱即用的功能，大大简化了团队上手的成本。 我觉得它适用于那些想使用容器管理平台 ，但是觉得 k8s 非常复杂又太基础，二次开发 k8s 没有精力和实力的团队。如果你们是这样的团队，我强烈建议你们考虑一下。
出于此目的与好奇心，所以我们来初体验一下。
初体验 本次我们的目的是在 Mac 下安装 Rancher 并发布一个 nginx 服务。
本人环境如下：
OS: macOS 10.15.7 Docker Engine: 20.</description></item><item><title>Go项目Gitlab CICD提速指南</title><link>/posts/2021/01/go/cicd/</link><pubDate>Sat, 16 Jan 2021 16:57:19 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2021/01/go/cicd/</guid><description>背景 我司使用GitLab作为代码仓库，Go项目在CICD过程中需要下载依赖，但大部分情况下依赖并未发生变化，重复下载是无用且非常耗时的操作，严重拖慢了CICD的效率。这对于任何一个追求效率的团队来说都是无法接受的。
之前也了解到一些go依赖缓存的解决方案，但不是特别优雅。从 Go 1.15 Release Notes 中看到，该版本新增了 GOMODCACHE 环境变量的支持，官方说明如下：
The location of the module cache may now be set with the GOMODCACHE environment variable. The default value of GOMODCACHE is GOPATH[0]/pkg/mod, the location of the module cache before this change. A workaround is now available for Windows &amp;quot;Access is denied&amp;quot; errors in go commands that access the module cache, caused by external programs concurrently scanning the file system (see issue #36568).</description></item><item><title>ELF格式简介</title><link>/posts/2020/12/linux/elf/</link><pubDate>Mon, 28 Dec 2020 10:56:34 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/12/linux/elf/</guid><description>概要 ELF 是一种文件格式。首次发布在名为 System Release 4 的 Unix 操作系统版本的 ABI 规范中，后来使用在 Tool interface standard中，然后迅速被不同的 Unix 发行版使用。在1999年，ELF 被选为 Unix 和 Unix-like 系统x86处理器的标准二进制文件格式。
文件格式 ELF 文件由 ELF File Header 和 Data 组成，Data 又由以下部分组成：
Program header table Section header table 1, 2 表头中引用的数据 ELF file header Program header Section header 示例 1readelf -all a.out 1 ELF Header: 2 Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 3 Class: ELF64 4 Data: 2&amp;#39;s complement, little endian 5 Version: 1 (current) 6 OS/ABI: UNIX - System V 7 ABI Version: 0 8 Type: EXEC (Executable file) 9 Machine: Advanced Micro Devices X86-64 10 Version: 0x1 11 Entry point address: 0x4003e0 12 Start of program headers: 64 (bytes into file) 13 Start of section headers: 2488 (bytes into file) 14 Flags: 0x0 15 Size of this header: 64 (bytes) 16 Size of program headers: 56 (bytes) 17 Number of program headers: 8 18 Size of section headers: 64 (bytes) 19 Number of section headers: 30 20 Section header string table index: 27 21 22 Section Headers: 23 [Nr] Name Type Address Offset 24 Size EntSize Flags Link Info Align 25 [ 0] NULL 0000000000000000 00000000 26 0000000000000000 0000000000000000 0 0 0 27 [ 1] .</description></item><item><title>Go源码解析之mutex</title><link>/posts/2020/11/go-src/sync/mutex/</link><pubDate>Mon, 16 Nov 2020 21:20:54 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/11/go-src/sync/mutex/</guid><description>概要 今天我们来看看Go中的互斥锁 sync/mutex。本文基于go1.15.5 进行分析。
我们借用互斥锁在维基百科上的定义：互斥锁（英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。
在Go中我们无法直接操作线程，使用 go 关键字启动的是goroutine，但goroutine的背后还是操作系统的线程，所以在此我们讨论的是多个goroutine之间的互斥锁。
用法 互斥锁的使用非常简单，初始化一个mutex，它的默认状态是unlock的。
Lock 方法表示这是临界区的开始，后续代码在访问公共资源时是受控的。调用该方法时，如果互斥锁已经是加锁的状态，goroutine将一直阻塞，直到锁释放。
Unlock 方法表示这是临界区的结束，之前的代码在访问公共资源时是受控的，但之后的将不再受控。调用该方法时，如果互斥锁是未加锁的状态，将会产生一个runtime error。
举个反例 1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;runtime&amp;#34; 6 &amp;#34;sync&amp;#34; 7 &amp;#34;time&amp;#34; 8) 9 10var ( 11 number int 12 mutex sync.Mutex 13) 14 15func main() { 16 runtime.GOMAXPROCS(10) 17 18 for i := 0; i &amp;lt; 1000; i++ { 19 go Add() 20 } 21 22 time.Sleep(time.Second) 23 fmt.Println(number) 24} 25 26func Add() { 27 number++ 28} 源代码可以在 Playground 查看。</description></item><item><title>Go条件编译</title><link>/posts/2020/11/go/build-constraints/</link><pubDate>Fri, 13 Nov 2020 18:39:55 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/11/go/build-constraints/</guid><description>最近在开发过程中遇到一个比较在编码上无解的问题，最终通过条件编译得到一个比较满意的方案。对于Go的条件编译，可能很多人都了解，甚至不知道。Go通过在行注释的前面编写如下代码来实现条件编译。
1// +build 条件编译的指令可能出现在任何源代码中，不止是*.go文件，可能是go汇编文件。无论是何种源文件，条件编译指令一定都出现在文件的顶部，并且在空行或者其他行注释之前。所以条件编译指令也必须在package语句之前。
编译规则 可以将 // +build 后面的内容当成一个表达式。当表达式返回true时，当前文件参与编译，反之不参与编译。
多个片段之间的空格表示它们之间是OR的关系。如下，表示GOOS值是linux或者darwin时，本文件参与编译。
1// +build linux darwin 多个片段之间的,表示它们之间是AND的关系。如下，表示GOOS值是linux且是amd64架构时，本文件参与编译。 1// +build linux,amd64 以!xxx开头的片段表示当tag xxx设置时，当前文件不参与编译。如下，表示GOOS值是linux时，本文件不参与编译。 1// +build !linux 单文件包含多个条件编译指令时，它们是AND的关系。如下，表示GOOS值是linux且是amd64架构时，本文件参与编译。 1// +build linux 2// +build amd64 一些内建的关键字。
GOOS的值，目标操作系统，如linux,darwin。 GOARCH的值，目标架构，如amd64。 编译器，gc 或者 gccgo。 cgo 如果cgo支持，编译。 gox.x 只在特定go版本进行编译，不支持beta or minor版本号的条件编译。 go build 命令的其他tag。 文件名实现条件编译。条件编译支持以下三种格式（源码文件名去除类型后缀和_test后缀后）：
*_GOOS GOOS值与文件名中的GOOS一致时参与编译。 *_GOARCH GOARCH值与文件名中的GOARCH一致时参与编译。 *_GOOS_GOARCH GOARCH,GOOS值与文件名中的GOARCH,GOOS一致时参与编译。 如 source_windows_amd64.go 该文件只在windows系统的amd64架构下进行编译。</description></item><item><title>Go源码解析之atomic</title><link>/posts/2020/11/go-src/sync/atomic/</link><pubDate>Sun, 08 Nov 2020 20:16:35 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/11/go-src/sync/atomic/</guid><description>今天我们来聊聊go的atomic pkg，atomic是go并发编程中最为基础的库。如果说它是go并发编程的基石一点也不为过，像标准库中大家使用率非常高的Mutex, RWMutex,WaitGroup,Once等的实现都依赖于atomic。
Atomic简介 atomic提供一系列用于实现同步功能的、底层的，原子的方法：
AddT 系列将增量增加到源值上，并返回新值。 CompareAndSwapT 系列比较两个变量的值，并进行交换。 SwapT系列交换值，并返回旧值。 LoadT 系列获取值。 StoreT 系列更新值。 Value 存储器，支持Load,Store。 这些方法是原子操作，不会被CPU中断，也就说在多个goroutine之间访问是安全的。
比如CompareAndSwapT方法，其实它包含多个步骤，在CPU执行时也是多个命令完成这个功能。
1if *addr == old { 2 *addr = new 3 return true 4} 5return false 那么go是如何让这些方法变成了原子操作呢？我们接着往下看。
刨根问底 为了搞清楚atomic到底是如何工作的，我们以CompareAndSwapInt32为例来分析。我打开了atomic的源代码。
1asm.s 2atomic_test.go 3doc.go 4example_test.go 5race.s 6value.go 7value_test.go 包内的文件数并不多，打开第一个asm.s，我们就看到非常重要的内容。
这是一个go汇编文件，我摘取了部分重要的内容。
1// +build !race 2 3#include &amp;#34;textflag.h&amp;#34; 4 5TEXT ·SwapInt32(SB),NOSPLIT,$0 6 JMP runtime∕internal∕atomic·Xchg(SB) 7 8// ...略去... 9 10TEXT ·CompareAndSwapInt32(SB),NOSPLIT,$0 11 JMP runtime∕internal∕atomic·Cas(SB) 12 13// .</description></item><item><title>Go设计模式之Factory</title><link>/posts/2020/10/factory/</link><pubDate>Wed, 14 Oct 2020 20:30:39 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/10/factory/</guid><description>Factory - 工厂模式 工厂模式在Go中使用的非常广泛，比如常用于数据的读写模块。假设我们需要从某种介质中读取数据，并将更新后的结果保存到该介质中。考虑到以后可能更换为其他类型的介质，为了避免日后更换介质而大面积变更代码，我们就会用到本模式。
实现 1.定义工厂方法所创建对象的接口 假设我们的存储模块只有Read和Write两个功能，我们需要先定义存储器inteface。
1package store 2 3import &amp;#34;io&amp;#34; 4 5type Store interface { 6 Read(string) ([]byte, error) 7 Save(string, []byte) (error) 8} 2.实现对象接口 假设我们需要将Redis或磁盘作为存储介质，我们需要分别实现Redis与磁盘的存储功能。
FileSystem 1pacakge store 2 3type FileStore struct{ 4 /*your codes*/ 5} 6 7func (store *FileStore) Read(string) ([]byte, error) { 8 /*your codes*/ 9} 10 11func (store *FileStore) Save(string, []byte) (error) { 12 /*your codes*/ 13} 14 15// 注意这里要返回 Store 接口，而不是FileStore的指针。 16// 可以保证工厂方法只能调用到对象接口方法，避免封装被破坏。 17func newFileStore() Store { 18 /*your codes*/ 19} Redis 1pacakge store 2 3type RedisStore struct{ 4 /*your codes*/ 5} 6 7func (store *RedisStore) Read(string) ([]byte, error) { 8 /*your codes*/ 9} 10 11func (store *RedisStore) Save(string, []byte) (error) { 12 /*your codes*/ 13} 14 15// 注意这里要返回 Store 接口，而不是RedisStore的指针。 16// 可以保证工厂方法只能调用到对象接口方法，避免封装被破坏。 17func newRedisStore() Store { 18 /*your codes*/ 19} 3.</description></item><item><title>Go设计模式之Singleton</title><link>/posts/2020/09/go-patterns/singleton/</link><pubDate>Wed, 30 Sep 2020 22:40:58 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/09/go-patterns/singleton/</guid><description>Singleton - 单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点。
实现 饿汉式 饿汉式单例是指在方法调用前，实例就已经创建好了。
按照用法使用，可以看到控制台输出10次单例的内存地址是一样的。
1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;sync&amp;#34; 6 &amp;#34;time&amp;#34; 7) 8 9type ( 10 server struct { 11 port int 12 } 13) 14 15var ( 16 instance = &amp;amp;server{} 17) 18 19func getServerSingleton() *server { 20 return instance 21} 22 23/* 24server ptr: 0x1182ec0 25server ptr: 0x1182ec0 26server ptr: 0x1182ec0 27server ptr: 0x1182ec0 28server ptr: 0x1182ec0 29server ptr: 0x1182ec0 30server ptr: 0x1182ec0 31server ptr: 0x1182ec0 32server ptr: 0x1182ec0 33server ptr: 0x1182ec0 34*/ 懒汉式 - 非Goroutine安全 懒汉式单例是指在方法调用获取实例时才创建实例，因为相对饿汉式显得“不急迫”，所以被叫做“懒汉模式”。</description></item><item><title>Go工具链之godoc</title><link>/posts/2020/09/go/godoc/</link><pubDate>Sun, 27 Sep 2020 21:30:30 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/09/go/godoc/</guid><description>在写boxgo的过程中，想要生成漂亮的godoc，发现不太熟悉godoc的用法，所以就有了本篇文章，记录一下。
Go团队非常重视文档，文档对项目的可阅读性、可维护性起到重要作用，所以写好文档变得非常重要。Go团队提供了godoc工具以帮助开发者方便、准确，容易的生成项目文档。godoc解析Go源代码（包括注释），并以HTML或纯文本格式生成文档。
生成文档 提取规则：
类型、变量、常量、函数，包都可以通过在声明的前面写注释的方法生成文档（中间不要有空行）。
1// Package doc 包注释 --- good 2package doc 3 4type ( 5 // UserType 类型注释 --- good 6 UserType string 7) 8 9var ( 10 // userType 变量注释 --- good 11 userType UserType 12) 13 14const ( 15 // Zero 常量注释 --- good 16 Zero = 0 17) 18 19// Test 函数注释 --- good 20func Test() { 21 22} 23 24 25// Test1 函数注释 --- bad（不要有空行） 26 27func Test1() { 28 29} 注释开头的字母需要与被注释的元素名称保持一致（包除外）。如函数Fprint注释开头的第一个字母也是Fprint。</description></item><item><title/><link>/about/</link><pubDate>Sat, 26 Sep 2020 21:30:30 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/about/</guid><description>Intro 喜欢倒腾的coder，常用Go/Node.Js/C/C++，对系统架构的设计与实现、微服务、ServiceMesh、DevOps、操作系统以及常用中间件略知一二。
喜欢解决问题的感觉，自认为是一个Problem slover，包括但不限于CS方向。如果觉得有必要，会不断优化争取把事情做到满意。
对技术有一点点小追求，偶尔在业务和产品方面也有一点点小想法，希望可以做出牛X的产品，为大家解决一些问题或者带来一些快乐。
Works 2013-2015 某安全公司 网络取证 C++/Node.js 2015-至今 某十大券商 互联网金融 Go/Node.js Contact Github Email: amazing.gao@qq.com Wechat: amazing-gao</description></item></channel></rss>