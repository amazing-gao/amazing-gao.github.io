<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Amazing-Gao 实在是高</title><link>/</link><description>Recent content on Amazing-Gao 实在是高</description><generator>Hugo 0.78.1 -- gohugo.io</generator><language>zh-cn</language><managingEditor>amazing.gao@qq.com (AmazingGao)</managingEditor><webMaster>amazing.gao@qq.com (AmazingGao)</webMaster><copyright>Amazing-Gao — All rights reserved.</copyright><lastBuildDate>Fri, 13 Nov 2020 18:39:55 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Go条件编译</title><link>/posts/2020/11/go/build-constraints/</link><pubDate>Fri, 13 Nov 2020 18:39:55 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid isPermaLink="true">/posts/2020/11/go/build-constraints/</guid><description>&lt;p>Go是支持条件编译，可能很多人都不知道。Go通过在行注释的前面编写如下代码来实现条件编译。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// +build
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>条件编译的指令可能出现在任何源代码中，不止是*.go文件，可能是go汇编文件。无论是何种源文件，条件编译指令一定都出现在文件的顶部，并且在空行或者其他行注释之前。所以条件编译指令也必须在package语句之前。&lt;/p>
&lt;hr>
&lt;h1 id="条件编译规则">条件编译规则&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>可以将 // +build 后面的内容当成一个表达式。当表达式返回true时，当前文件参与编译，反之不参与编译。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>多个片段之间的空格表示它们之间是OR的关系。如下，表示GOOS值是linux或者darwin时，本文件参与编译。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// +build linux darwin
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>多个片段之间的,表示它们之间是AND的关系。如下，表示GOOS值是linux且是amd64架构时，本文件参与编译。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// +build linux,amd64
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>以!xxx开头的片段表示当tag xxx设置时，当前文件不参与编译。如下，表示GOOS值是linux时，本文件不参与编译。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// +build !linux
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>单文件包含多个条件编译指令时，它们是AND的关系。如下，表示GOOS值是linux且是amd64架构时，本文件参与编译。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// +build linux
&lt;/span>&lt;span style="color:#75715e">// +build amd64
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="6">
&lt;li>
&lt;p>一些内建的关键字。&lt;/p>
&lt;ol>
&lt;li>&lt;code>GOOS&lt;/code>的值，目标操作系统，如linux,darwin。&lt;/li>
&lt;li>&lt;code>GOARCH&lt;/code>的值，目标架构，如amd64。&lt;/li>
&lt;li>编译器，&lt;code>gc&lt;/code> 或者 &lt;code>gccgo&lt;/code>。&lt;/li>
&lt;li>&lt;code>cgo&lt;/code> 如果cgo支持，编译。&lt;/li>
&lt;li>&lt;code>gox.x&lt;/code> 只在特定go版本进行编译，不支持beta or minor版本号的条件编译。&lt;/li>
&lt;li>&lt;code>go build&lt;/code> 命令的其他tag。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>文件名实现条件编译。条件编译支持以下三种格式（&lt;code>源码文件名去除类型后缀和_test后缀后&lt;/code>）：&lt;/p>
&lt;ol>
&lt;li>&lt;code>*_GOOS&lt;/code> GOOS值与文件名中的GOOS一致时参与编译。&lt;/li>
&lt;li>&lt;code>*_GOARCH&lt;/code> GOARCH值与文件名中的GOARCH一致时参与编译。&lt;/li>
&lt;li>&lt;code>*_GOOS_GOARCH&lt;/code> GOARCH,GOOS值与文件名中的GOARCH,GOOS一致时参与编译。&lt;/li>
&lt;/ol>
&lt;p>如 &lt;code>source_windows_amd64.go&lt;/code> 该文件只在&lt;code>windows&lt;/code>系统的&lt;code>amd64&lt;/code>架构下进行编译。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="示例">示例&lt;/h1>
&lt;p>示例的文件目录:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ tree .
$ .
$ ├── etcd.go
$ ├── go.mod
$ ├── main.go
$ └── redis.go
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>etcd.go&lt;/code> 当tags中出现etcd字符时，不参与编译。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// +build !etcd
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#a6e22e">fun&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
println(&lt;span style="color:#e6db74">&amp;#34;etcd init&amp;#34;&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>redis.go&lt;/code> 当tags中出现redis字符时，不参与编译。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// +build !redis
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#a6e22e">fun&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
println(&lt;span style="color:#e6db74">&amp;#34;redis redis&amp;#34;&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>main.go&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
println(&lt;span style="color:#e6db74">&amp;#34;hell world!&amp;#34;&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面我们来看看效果吧！&lt;/p>
&lt;ol>
&lt;li>直接编译，不执行条件编译&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ go run .
$ etcd init
$ redis init
$ hell world!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，etcd.go,redis.go,main.go都被编译了。&lt;/p>
&lt;ol>
&lt;li>不编译redis.go文件&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ go run -tags redis . &lt;span style="color:#75715e"># 我们使用 `-tags` 来设置编译条件。&lt;/span>
$ etcd init
$ hell world!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时候我们看到，只有etcd.go和main.go被编译了，redis.go中的init方法没有被执行。&lt;/p>
&lt;ol start="3">
&lt;li>不编译etcd.go文件&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ go run -tags etcd . &lt;span style="color:#75715e"># 我们使用 `-tags` 来设置编译条件。&lt;/span>
$ redis init
$ hell world!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时候我们看到，只有redis.go和main.go被编译了，main.go中的init方法没有被执行。&lt;/p>
&lt;ol start="4">
&lt;li>不编译etcd.go和redis.go文件&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ go run -tags etcd,redis . &lt;span style="color:#75715e"># 我们使用 `-tags` 来设置编译条件。&lt;/span>
$ hell world!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时候我们看到，只有main.go文件中的main函数被执行了，其他文件中的init方法均没有被执行。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>在go的源代码中条件编译使用的非常广泛。比如某些功能在不同操作系统的实现不一样，这时候我们就需要针对不同操作系统分别编写代码，但这些代码都在一个目录中，如果没有条件编译将无法编译成功。又或者我们的配置信息可能来自Redis,Etcd,ZooKeeper等不同的配置源，但在运行时我们只用到Etcd，这时候我们可以对代码进行拆分并编写条件编译指令，在编译时只编译Etcd数据源的代码以减小不必要的依赖。&lt;/p>
&lt;p>有些靠编写代码没法控制事情，通过条件编译也许可以帮助你，总之掌握条件编译可以帮助我们更好的完成开发工作，甚至实现一些普通程序员无法理解的“黑科技”。&lt;/p>
&lt;p>更多信息请查看官方介绍&lt;a href="https://golang.org/cmd/g/o#hdr-Build_constraints">Build Constraints&lt;/a>。&lt;/p></description></item><item><title>Go源码解析之atomic</title><link>/posts/2020/11/go-src/sync/atomic/</link><pubDate>Sun, 08 Nov 2020 20:16:35 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid isPermaLink="true">/posts/2020/11/go-src/sync/atomic/</guid><description>&lt;p>今天我们来聊聊go的&lt;strong>atomic&lt;/strong> pkg，&lt;strong>atomic&lt;/strong>是go并发编程中最为基础的库。如果说它是go并发编程的基石一点也不为过，像标准库中大家使用率非常高的&lt;strong>Mutex&lt;/strong>, &lt;strong>RWMutex&lt;/strong>,&lt;strong>WaitGroup&lt;/strong>,&lt;strong>Once&lt;/strong>等的实现都依赖于&lt;strong>atomic&lt;/strong>。&lt;/p>
&lt;h1 id="atomic简介">Atomic简介&lt;/h1>
&lt;p>&lt;strong>atomic&lt;/strong>提供一系列用于实现同步功能的、底层的，原子的方法：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>AddT&lt;/strong> 系列将增量增加到源值上，并返回新值。&lt;/li>
&lt;li>&lt;strong>CompareAndSwapT&lt;/strong> 系列比较两个变量的值，并进行交换。&lt;/li>
&lt;li>&lt;strong>SwapT&lt;/strong>系列交换值，并返回旧值。&lt;/li>
&lt;li>&lt;strong>LoadT&lt;/strong> 系列获取值。&lt;/li>
&lt;li>&lt;strong>StoreT&lt;/strong> 系列更新值。&lt;/li>
&lt;li>&lt;strong>Value&lt;/strong> 存储器，支持Load,Store。&lt;/li>
&lt;/ol>
&lt;p>这些方法是原子操作，不会被CPU中断，也就说在多个goroutine之间访问是安全的。&lt;/p>
&lt;p>比如&lt;strong>CompareAndSwapT&lt;/strong>方法，其实它包含多个步骤，在CPU执行时也是多个命令完成这个功能。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">addr&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">old&lt;/span> {
&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">addr&lt;/span> = &lt;span style="color:#a6e22e">new&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么go是如何让这些方法变成了原子操作呢？我们接着往下看。&lt;/p>
&lt;h1 id="刨根问底">刨根问底&lt;/h1>
&lt;p>为了搞清楚&lt;strong>atomic&lt;/strong>到底是如何工作的，我们以&lt;strong>CompareAndSwapInt32&lt;/strong>为例来分析。我打开了&lt;a href="https://github.com/golang/go/tree/master/src/sync/atomic">atomic&lt;/a>的源代码。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">asm.s
atomic_test.go
doc.go
example_test.go
race.s
value.go
value_test.go
&lt;/code>&lt;/pre>&lt;/div>&lt;p>包内的文件数并不多，打开第一个&lt;strong>asm.s&lt;/strong>，我们就看到非常重要的内容。&lt;/p>
&lt;p>这是一个go汇编文件，我摘取了部分重要的内容。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">// +build !race
#include &amp;#34;textflag.h&amp;#34;
TEXT ·SwapInt32(SB),NOSPLIT,$0
JMP runtime∕internal∕atomic·Xchg(SB)
// ...略去...
TEXT ·CompareAndSwapInt32(SB),NOSPLIT,$0
JMP runtime∕internal∕atomic·Cas(SB)
// ...略去...
TEXT ·AddInt32(SB),NOSPLIT,$0
JMP runtime∕internal∕atomic·Xadd(SB)
// ...略去...
TEXT ·LoadInt32(SB),NOSPLIT,$0
JMP runtime∕internal∕atomic·Load(SB)
// ...略去...
TEXT ·StoreInt32(SB),NOSPLIT,$0
JMP runtime∕internal∕atomic·Store(SB)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>// +build !race&lt;/code> 这是go的条件编译，表示race时不编译，不是本文重点，欲知更多请查看&lt;a href="https://golang.org/cmd/go/#hdr-Build_constraints">Go build constraints&lt;/a>。&lt;code>#include &amp;quot;textflag.h&amp;quot;&lt;/code> 引用头文件，定义了一些宏。&lt;/p>
&lt;p>下面来到我们的重点 &lt;code>TEXT ·CompareAndSwapInt32(SB),NOSPLIT,$0&lt;/code> 定义了CompareAndSwapInt32函数，可以看到它并没有什么逻辑，直接跳转去了&lt;code>runtime∕internal∕atomic·Cas&lt;/code>。那么我们就跟过去。&lt;/p>
&lt;p>我们查看amd64版本代码&lt;a href="https://github.com/golang/go/blob/master/src/runtime/internal/atomic/stubs.go#L12">stubs.go&lt;/a>，看到了函数的声明*&lt;em>func Cas(ptr &lt;em>uint32, old, new uint32) bool&lt;/em>&lt;/em>，但是并没有函数体。Go还可以这么玩？函数体去哪里了？&lt;/p>
&lt;p>经过一番侦查，在&lt;a href="https://github.com/golang/go/blob/master/src/runtime/internal/atomic/asm_amd64.s#L17">asm_amd64.s&lt;/a>中发现了汇编实现的函数体。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">// bool Cas(int32 *val, int32 old, int32 new)
// Atomically:
// if(*val == old){
// *val = new;
// return 1;
// } else
// return 0;
TEXT runtime∕internal∕atomic·Cas(SB),NOSPLIT,$0-17
MOVQ ptr+0(FP), BX
MOVL old+8(FP), AX
MOVL new+12(FP), CX
LOCK
CMPXCHGL CX, 0(BX)
SETEQ ret+16(FP)
RET
&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一行MOVQ ptr到BX寄存器。&lt;strong>FP&lt;/strong> 是go汇编定义的伪寄存器，伪FP寄存器对应的是函数的帧指针，一般用来访问函数的参数和返回值。Go汇编是基于&lt;a href="https://9p.io/sys/doc/asm.html">plan9&lt;/a>的，MOV的方向和我们常规学习到的相反。&lt;/p>
&lt;p>第二行MOVL old值到AX寄存器。&lt;/p>
&lt;p>第三行MOVL new值到CX寄存器。&lt;/p>
&lt;p>第四行&lt;strong>LOCK&lt;/strong>，这个命令非常陌生。经过一番资料查询了解到&lt;a href="https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf">Intel® 64 and IA-32 Architectures Software Developer’s Manual&lt;/a>，LOCK能将后续的指令变成原子操作，那么后续的&lt;strong>CMPXCHGL&lt;/strong>也将被原子化。&lt;/p>
&lt;p>第五行CMPXCHGL CX, 0(BX)，将BX的值(ptr)与CX的值(new)比较。如果相等，CX更新到ptr，否者BX更新到AX。&lt;/p>
&lt;p>第六行SETEQ ret+16(FP)，如果ZF标志位为0，设置1到返回值(FP偏移16位)，否者设置0。&lt;/p>
&lt;p>第七行RET 函数返回。&lt;/p>
&lt;hr>
&lt;p>这里最重要的是&lt;strong>LOCK&lt;/strong>与&lt;strong>CMPXCHGL&lt;/strong>两个命令，两条命令组合完成了Cas操作。这是CPU支持的原子操作。后续补充CPU这块关于LOCK的一些介绍。&lt;/p>
&lt;hr>
&lt;p>atomic中其他方法实现原子操作的方案基本与此一致，在此就不赘述了，有兴趣的童鞋可以自己研究一下。&lt;/p>
&lt;h1 id="参考文档">参考文档：&lt;/h1>
&lt;ol>
&lt;li>&lt;a href="https://wweir.cc/post/%E6%8E%A2%E7%B4%A2-golang-%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E8%AF%AD/">探索 Golang 一致性原语&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Go设计模式之Factory</title><link>/posts/2020/10/factory/</link><pubDate>Wed, 14 Oct 2020 20:30:39 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid isPermaLink="true">/posts/2020/10/factory/</guid><description>&lt;h1 id="factory---工厂模式">Factory - 工厂模式&lt;/h1>
&lt;p>工厂模式在Go中使用的非常广泛，比如常用于数据的读写模块。假设我们需要从某种介质中读取数据，并将更新后的结果保存到该介质中。考虑到以后可能更换为其他类型的介质，为了避免日后更换介质而大面积变更代码，我们就会用到本模式。&lt;/p>
&lt;h1 id="实现">实现&lt;/h1>
&lt;h2 id="1定义工厂方法所创建对象的接口">1.定义工厂方法所创建对象的接口&lt;/h2>
&lt;p>假设我们的存储模块只有&lt;strong>Read&lt;/strong>和&lt;strong>Write&lt;/strong>两个功能，我们需要先定义存储器&lt;strong>inteface&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">store&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;io&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Store&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Read&lt;/span>(&lt;span style="color:#66d9ef">string&lt;/span>) ([]&lt;span style="color:#66d9ef">byte&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>)
&lt;span style="color:#a6e22e">Save&lt;/span>(&lt;span style="color:#66d9ef">string&lt;/span>, []&lt;span style="color:#66d9ef">byte&lt;/span>) (&lt;span style="color:#66d9ef">error&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2实现对象接口">2.实现对象接口&lt;/h2>
&lt;p>假设我们需要将Redis或磁盘作为存储介质，我们需要分别实现Redis与磁盘的存储功能。&lt;/p>
&lt;h3 id="filesystem">FileSystem&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">pacakge&lt;/span> &lt;span style="color:#a6e22e">store&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FileStore&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{
&lt;span style="color:#75715e">/*your codes*/&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">store&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FileStore&lt;/span>) &lt;span style="color:#a6e22e">Read&lt;/span>(&lt;span style="color:#66d9ef">string&lt;/span>) ([]&lt;span style="color:#66d9ef">byte&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#75715e">/*your codes*/&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">store&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FileStore&lt;/span>) &lt;span style="color:#a6e22e">Save&lt;/span>(&lt;span style="color:#66d9ef">string&lt;/span>, []&lt;span style="color:#66d9ef">byte&lt;/span>) (&lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#75715e">/*your codes*/&lt;/span>
}
&lt;span style="color:#75715e">// 注意这里要返回 Store 接口，而不是FileStore的指针。
&lt;/span>&lt;span style="color:#75715e">// 可以保证工厂方法只能调用到对象接口方法，避免封装被破坏。
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">newFileStore&lt;/span>() &lt;span style="color:#a6e22e">Store&lt;/span> {
&lt;span style="color:#75715e">/*your codes*/&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="redis">Redis&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">pacakge&lt;/span> &lt;span style="color:#a6e22e">store&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">RedisStore&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{
&lt;span style="color:#75715e">/*your codes*/&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">store&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RedisStore&lt;/span>) &lt;span style="color:#a6e22e">Read&lt;/span>(&lt;span style="color:#66d9ef">string&lt;/span>) ([]&lt;span style="color:#66d9ef">byte&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#75715e">/*your codes*/&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">store&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RedisStore&lt;/span>) &lt;span style="color:#a6e22e">Save&lt;/span>(&lt;span style="color:#66d9ef">string&lt;/span>, []&lt;span style="color:#66d9ef">byte&lt;/span>) (&lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#75715e">/*your codes*/&lt;/span>
}
&lt;span style="color:#75715e">// 注意这里要返回 Store 接口，而不是RedisStore的指针。
&lt;/span>&lt;span style="color:#75715e">// 可以保证工厂方法只能调用到对象接口方法，避免封装被破坏。
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">newRedisStore&lt;/span>() &lt;span style="color:#a6e22e">Store&lt;/span> {
&lt;span style="color:#75715e">/*your codes*/&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="3实现工厂方法">3.实现工厂方法&lt;/h2>
&lt;p>工厂方法是暴露给模块外部使用的，用于创建实例的方法。我们需要将各种类型&lt;strong>Store&lt;/strong>实例的创建过程封装到该方法里面，避免暴露给外部模块。由工厂方法统一提供创建功能。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">pacakge&lt;/span> &lt;span style="color:#a6e22e">store&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> (
&lt;span style="color:#a6e22e">StoreType&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
)
&lt;span style="color:#66d9ef">const&lt;/span> (
&lt;span style="color:#a6e22e">File&lt;/span> &lt;span style="color:#a6e22e">StorageType&lt;/span> = &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#66d9ef">iota&lt;/span>
&lt;span style="color:#a6e22e">Redis&lt;/span>
)
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewStore&lt;/span>(&lt;span style="color:#a6e22e">storeType&lt;/span> &lt;span style="color:#a6e22e">StoreType&lt;/span>) &lt;span style="color:#a6e22e">Store&lt;/span> {
&lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">storeType&lt;/span> {
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#a6e22e">File&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">newFileStore&lt;/span>()
&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#a6e22e">Redis&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">newRedisStore&lt;/span>()
&lt;span style="color:#66d9ef">default&lt;/span>:
panic(&lt;span style="color:#e6db74">&amp;#34;尚未支持的存储类型！&amp;#34;&lt;/span>)
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="使用">使用&lt;/h1>
&lt;p>假设我们需要使用&lt;strong>Redis&lt;/strong>作为存储介质，我们只需要在工厂方法中传入&lt;strong>store.Redis&lt;/strong>参数。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> (
&lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;xxxx/store&amp;#34;&lt;/span> &lt;span style="color:#75715e">// 你的模块地址
&lt;/span>&lt;span style="color:#75715e">&lt;/span>)
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#a6e22e">st&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">store&lt;/span>.&lt;span style="color:#a6e22e">NewStore&lt;/span>(&lt;span style="color:#a6e22e">store&lt;/span>.&lt;span style="color:#a6e22e">Redis&lt;/span>)
&lt;span style="color:#75715e">// 读取数据
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">data&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">st&lt;/span>.&lt;span style="color:#a6e22e">Read&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/foo&amp;#34;&lt;/span>)
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>, &lt;span style="color:#a6e22e">data&lt;/span>)
&lt;span style="color:#75715e">// 保存数据
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> = &lt;span style="color:#a6e22e">st&lt;/span>.&lt;span style="color:#a6e22e">Write&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/foo&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">data&lt;/span>)
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果现在我们想更换介质为文件系统，我们只需要更换工厂方法中传入的参数为&lt;strong>store.File&lt;/strong>即可完成介质更换。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// 其他代码不变
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// 工厂方法的参数更改为store.File即可。
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">st&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">store&lt;/span>.&lt;span style="color:#a6e22e">NewStore&lt;/span>(&lt;span style="color:#a6e22e">store&lt;/span>.&lt;span style="color:#a6e22e">File&lt;/span>)
&lt;span style="color:#75715e">// 其他代码不变
&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Go设计模式之Singleton</title><link>/posts/2020/09/go-patterns/singleton/</link><pubDate>Wed, 30 Sep 2020 22:40:58 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid isPermaLink="true">/posts/2020/09/go-patterns/singleton/</guid><description>&lt;h1 id="singleton---单例模式">Singleton - 单例模式&lt;/h1>
&lt;p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p>
&lt;h1 id="实现">实现&lt;/h1>
&lt;h2 id="饿汉式">饿汉式&lt;/h2>
&lt;p>饿汉式单例是指在方法调用前，实例就已经创建好了。&lt;/p>
&lt;p>按照&lt;strong>用法&lt;/strong>使用，可以看到控制台输出10次单例的内存地址是一样的。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> (
&lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;sync&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;time&amp;#34;&lt;/span>
)
&lt;span style="color:#66d9ef">type&lt;/span> (
&lt;span style="color:#a6e22e">server&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">port&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
}
)
&lt;span style="color:#66d9ef">var&lt;/span> (
&lt;span style="color:#a6e22e">instance&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">server&lt;/span>{}
)
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">getServerSingleton&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">server&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">instance&lt;/span>
}
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182ec0
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182ec0
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182ec0
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182ec0
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182ec0
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182ec0
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182ec0
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182ec0
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182ec0
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182ec0
&lt;/span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="懒汉式---非goroutine安全">懒汉式 - 非Goroutine安全&lt;/h2>
&lt;p>懒汉式单例是指在方法调用获取实例时才创建实例，因为相对饿汉式显得“不急迫”，所以被叫做“懒汉模式”。&lt;/p>
&lt;p>按照&lt;strong>用法&lt;/strong>使用，可以看到控制台输出10次单例的内存地址并不完全一样。&lt;/p>
&lt;p>一共有以下3个指针：&lt;/p>
&lt;ul>
&lt;li>0xc0000c4000&lt;/li>
&lt;li>0xc0000ca000&lt;/li>
&lt;li>0xc0000c2000&lt;/li>
&lt;/ul>
&lt;p>可见此懒汉模式不支持在实例未初始化时高并发调用。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> (
&lt;span style="color:#a6e22e">server&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">port&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
}
)
&lt;span style="color:#66d9ef">var&lt;/span> (
&lt;span style="color:#a6e22e">instance&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">server&lt;/span>
)
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">getServerSingleton&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">server&lt;/span> {
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">instance&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">instance&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">server&lt;/span>{}
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">instance&lt;/span>
}
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e">server ptr: 0xc0000c4000
&lt;/span>&lt;span style="color:#75715e">server ptr: 0xc0000ca000
&lt;/span>&lt;span style="color:#75715e">server ptr: 0xc0000c4000
&lt;/span>&lt;span style="color:#75715e">server ptr: 0xc0000c2000
&lt;/span>&lt;span style="color:#75715e">server ptr: 0xc0000c2000
&lt;/span>&lt;span style="color:#75715e">server ptr: 0xc0000ca000
&lt;/span>&lt;span style="color:#75715e">server ptr: 0xc0000ca000
&lt;/span>&lt;span style="color:#75715e">server ptr: 0xc0000ca000
&lt;/span>&lt;span style="color:#75715e">server ptr: 0xc0000ca000
&lt;/span>&lt;span style="color:#75715e">server ptr: 0xc0000ca000
&lt;/span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="懒汉式---goroutine安全">懒汉式 - Goroutine安全&lt;/h2>
&lt;p>我们可以利用golang sync包提供的Once结构体来解决Goroutine安全问题。Once提供了在应用程序生命周期中仅会被调用一次的解决方案。我们将实例的生成过程使用Once保护起来，那么即可以做到单例。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> (
&lt;span style="color:#e6db74">&amp;#34;sync&amp;#34;&lt;/span>
)
&lt;span style="color:#66d9ef">type&lt;/span> (
&lt;span style="color:#a6e22e">server&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{}
)
&lt;span style="color:#66d9ef">var&lt;/span> (
&lt;span style="color:#a6e22e">instance&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">server&lt;/span>
&lt;span style="color:#a6e22e">once&lt;/span> &lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">Once&lt;/span>
)
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">getServerSingleton&lt;/span>() &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">server&lt;/span> {
&lt;span style="color:#a6e22e">once&lt;/span>.&lt;span style="color:#a6e22e">Do&lt;/span>(&lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;span style="color:#a6e22e">instance&lt;/span> = &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">server&lt;/span>{}
})
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">instance&lt;/span>
}
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182f88
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182f88
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182f88
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182f88
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182f88
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182f88
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182f88
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182f88
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182f88
&lt;/span>&lt;span style="color:#75715e">server ptr: 0x1182f88
&lt;/span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="用法">用法&lt;/h1>
&lt;p>模拟10个并发请求获取单例。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#a6e22e">wg&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">WaitGroup&lt;/span>{}
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">index&lt;/span> &amp;lt; &lt;span style="color:#ae81ff">10&lt;/span>; &lt;span style="color:#a6e22e">index&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;span style="color:#a6e22e">wg&lt;/span>.&lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Sleep&lt;/span>(&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Millisecond&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>)
&lt;span style="color:#a6e22e">server&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">getServerSingleton&lt;/span>()
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;server ptr: %p \n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">server&lt;/span>)
&lt;span style="color:#a6e22e">wg&lt;/span>.&lt;span style="color:#a6e22e">Done&lt;/span>()
}()
}
&lt;span style="color:#a6e22e">wg&lt;/span>.&lt;span style="color:#a6e22e">Wait&lt;/span>()
}
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>godoc使用指南</title><link>/posts/2020/09/go/godoc/</link><pubDate>Sun, 27 Sep 2020 21:30:30 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid isPermaLink="true">/posts/2020/09/go/godoc/</guid><description>&lt;p>在写&lt;a href="https://github.com/boxgo/box">boxgo&lt;/a>的过程中，想要生成漂亮的godoc，发现不太熟悉godoc的用法，所以就有了本篇文章，记录一下。&lt;/p>
&lt;p>Go团队非常重视文档，文档对项目的可阅读性、可维护性起到重要作用，所以写好文档变得非常重要。Go团队提供了&lt;code>godoc&lt;/code>工具以帮助开发者方便、准确，容易的生成项目文档。&lt;code>godoc&lt;/code>解析Go源代码（包括注释），并以HTML或纯文本格式生成文档。&lt;/p>
&lt;h1 id="生成文档">生成文档&lt;/h1>
&lt;p>提取规则：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>类型、变量、常量、函数，包都可以通过在声明的前面写注释的方法生成文档（中间不要有空行）。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// Package doc 包注释 --- good
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">doc&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> (
&lt;span style="color:#75715e">// UserType 类型注释 --- good
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">UserType&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
)
&lt;span style="color:#66d9ef">var&lt;/span> (
&lt;span style="color:#75715e">// userType 变量注释 --- good
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">userType&lt;/span> &lt;span style="color:#a6e22e">UserType&lt;/span>
)
&lt;span style="color:#66d9ef">const&lt;/span> (
&lt;span style="color:#75715e">// Zero 常量注释 --- good
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Zero&lt;/span> = &lt;span style="color:#ae81ff">0&lt;/span>
)
&lt;span style="color:#75715e">// Test 函数注释 --- good
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Test&lt;/span>() {
}
&lt;span style="color:#75715e">// Test1 函数注释 --- bad（不要有空行）
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Test1&lt;/span>() {
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>注释开头的字母需要与被注释的元素名称保持一致（&lt;code>包&lt;/code>除外）。如函数&lt;code>Fprint&lt;/code>注释开头的第一个字母也是&lt;code>Fprint&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// Fprint formats using the default formats for its operands and writes to w.
&lt;/span>&lt;span style="color:#75715e">// Spaces are added between operands when neither is a string.
&lt;/span>&lt;span style="color:#75715e">// It returns the number of bytes written and any write error encountered.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Fprint&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span> &lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">Writer&lt;/span>, &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">...&lt;/span>&lt;span style="color:#66d9ef">interface&lt;/span>{}) (&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#75715e">//
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>doc.go&lt;/code> - 包注释比较多的话也可以使用单独的&lt;code>doc.go&lt;/code>来编写文档。参考&lt;a href="https://golang.org/src/encoding/gob/doc.go">gob package&amp;rsquo;s doc&lt;/a>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>BUG(who)&lt;/code> - 注释与被注释主体之间通常不能有空行或者空注释，但是&lt;code>BUG(who)&lt;/code>是一个例外，&lt;code>BUG&lt;/code>将在godoc的文档中展示。参考：&lt;a href="https://golang.org/pkg/bytes/#pkg-note-BUG">bytes package&lt;/a>。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin
&lt;/span>&lt;span style="color:#75715e">// words mapped to their title case.
&lt;/span>&lt;span style="color:#75715e">//
&lt;/span>&lt;span style="color:#75715e">// BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Title&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>Deprecated&lt;/code> - 可以描述struct field, function, type, variable, const甚至是package，表示被弃用，后续不再使用，但必须保持兼容性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>多个相邻的注释行，生成文档时被视为一个段落，如果想要生成多个段落，请留空行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>预格式文本需要相对上下文的注释有缩进。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>URL无需标记，文档中也会被转换成URL。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="查看文档">查看文档&lt;/h1>
&lt;p>几行代码带你查看你项目的godoc。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#75715e"># 进入你的项目源代码目录&lt;/span>
cd $your_project_dir
&lt;span style="color:#75715e"># 为项目建立软连接，因为godoc目前对go mod支持的不是很好，所以需要将项目软链到GOPATH内。如果你的项目在GOPATH目录中，跳过此步骤。&lt;/span>
ln -s $your_project_dir $GOPATH/src/$your_module_path
&lt;span style="color:#75715e"># 启动godoc服务&lt;/span>
godoc -http&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;:6060&amp;#34;&lt;/span>
&lt;span style="color:#75715e"># mac下查看文档。其他操作系统请打开浏览器访问。&lt;/span>
open http://127.0.0.1:6060/pkg/$your_module_path
&lt;/code>&lt;/pre>&lt;/div>&lt;p>效果图&lt;/p>
&lt;p>&lt;img src="/posts/godoc/image-20200928161749381.png" alt="image-20200928161749381">&lt;/p>
&lt;h1 id="参考文档">参考文档&lt;/h1>
&lt;p>&lt;a href="https://pkg.go.dev/golang.org/x/tools/cmd/godoc">godoc command&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.golang.org/godoc">godoc blog&lt;/a>&lt;/p></description></item><item><title/><link>/about/</link><pubDate>Sat, 26 Sep 2020 21:30:30 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid isPermaLink="true">/about/</guid><description>&lt;p>喜欢倒腾的backend coder，常用Go/Node.Js/C/C++，对系统架构的设计与实现、微服务、ServiceMesh、DevOps、操作系统以及常用中间件略知一二。&lt;/p>
&lt;p>喜欢解决问题的感觉，自认为是一个Problem slover，包括但不限于CS方向。如果觉得有必要，会不断优化争取把事情做到满意。&lt;/p>
&lt;p>对技术有一点点小追求，偶尔在业务和产品方面也有一点点小想法，希望可以做出牛X的产品，为大家解决一些问题或者带来一些快乐。&lt;/p>
&lt;h1 id="经历">经历&lt;/h1>
&lt;ul>
&lt;li>2013-2015 某安全公司 网络取证 C++/Node.js&lt;/li>
&lt;li>2015-至今 某十大券商 互联网金融 Go/Node.js&lt;/li>
&lt;/ul>
&lt;h1 id="联系我">联系我&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://github.com/amazing-gao">Github&lt;/a>&lt;/li>
&lt;li>Email: &lt;a href="mailto:amazing.gao@qq.com">amazing.gao@qq.com&lt;/a>&lt;/li>
&lt;li>Wechat: amazing-gao&lt;/li>
&lt;/ul></description></item></channel></rss>