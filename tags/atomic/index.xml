<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>atomic on Amazing-Gao 实在是高</title><link>/tags/atomic/</link><description>Recent content in atomic on Amazing-Gao 实在是高</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>amazing.gao@qq.com (AmazingGao)</managingEditor><webMaster>amazing.gao@qq.com (AmazingGao)</webMaster><copyright>Amazing-Gao — All rights reserved.</copyright><lastBuildDate>Sun, 08 Nov 2020 20:16:35 +0800</lastBuildDate><atom:link href="/tags/atomic/index.xml" rel="self" type="application/rss+xml"/><item><title>Go源码解析之atomic</title><link>/posts/2020/11/go-src/sync/atomic/</link><pubDate>Sun, 08 Nov 2020 20:16:35 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/11/go-src/sync/atomic/</guid><description>今天我们来聊聊go的atomic pkg，atomic是go并发编程中最为基础的库。如果说它是go并发编程的基石一点也不为过，像标准库中大家使用率非常高的Mutex, RWMutex,WaitGroup,Once等的实现都依赖于atomic。
Atomic简介 atomic提供一系列用于实现同步功能的、底层的，原子的方法：
AddT 系列将增量增加到源值上，并返回新值。 CompareAndSwapT 系列比较两个变量的值，并进行交换。 SwapT系列交换值，并返回旧值。 LoadT 系列获取值。 StoreT 系列更新值。 Value 存储器，支持Load,Store。 这些方法是原子操作，不会被CPU中断，也就说在多个goroutine之间访问是安全的。
比如CompareAndSwapT方法，其实它包含多个步骤，在CPU执行时也是多个命令完成这个功能。
1if *addr == old { 2 *addr = new 3 return true 4} 5return false 那么go是如何让这些方法变成了原子操作呢？我们接着往下看。
刨根问底 为了搞清楚atomic到底是如何工作的，我们以CompareAndSwapInt32为例来分析。我打开了atomic的源代码。
1asm.s 2atomic_test.go 3doc.go 4example_test.go 5race.s 6value.go 7value_test.go 包内的文件数并不多，打开第一个asm.s，我们就看到非常重要的内容。
这是一个go汇编文件，我摘取了部分重要的内容。
1// +build !race 2 3#include &amp;#34;textflag.h&amp;#34; 4 5TEXT ·SwapInt32(SB),NOSPLIT,$0 6 JMP runtime∕internal∕atomic·Xchg(SB) 7 8// ...略去... 9 10TEXT ·CompareAndSwapInt32(SB),NOSPLIT,$0 11 JMP runtime∕internal∕atomic·Cas(SB) 12 13// .</description></item></channel></rss>