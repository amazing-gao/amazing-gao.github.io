<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sync on Amazing-Gao 实在是高</title><link>/tags/sync/</link><description>Recent content in sync on Amazing-Gao 实在是高</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>amazing.gao@qq.com (AmazingGao)</managingEditor><webMaster>amazing.gao@qq.com (AmazingGao)</webMaster><copyright>Amazing-Gao — All rights reserved.</copyright><lastBuildDate>Mon, 16 Nov 2020 21:20:54 +0800</lastBuildDate><atom:link href="/tags/sync/index.xml" rel="self" type="application/rss+xml"/><item><title>Go源码解析之mutex</title><link>/posts/2020/11/go-src/sync/mutex/</link><pubDate>Mon, 16 Nov 2020 21:20:54 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/11/go-src/sync/mutex/</guid><description>概要 今天我们来看看Go中的互斥锁 sync/mutex。
我们借用互斥锁在维基百科上的定义：互斥锁（英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。
在Go中我们无法直接操作线程，使用 go 关键字启动的是goroutine，但goroutine的背后还是操作系统的线程，所以在此我们讨论的是多个goroutine之间的互斥锁。
用法 互斥锁的使用非常简单，初始化一个mutex，它的默认状态是unlock的。
Lock 方法表示这是临界区的开始，后续代码在访问公共资源时是受控的。调用该方法时，如果互斥锁已经是加锁的状态，goroutine将一直阻塞，直到锁释放。
Unlock 方法表示这是临界区的结束，之前的代码在访问公共资源时是受控的，但之后的将不再受控。调用该方法时，如果互斥锁是未加锁的状态，将会产生一个runtime error。
举个反例 1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;runtime&amp;#34; 6 &amp;#34;sync&amp;#34; 7 &amp;#34;time&amp;#34; 8) 9 10var ( 11 number int 12 mutex sync.Mutex 13) 14 15func main() { 16 runtime.GOMAXPROCS(10) 17 18 for i := 0; i &amp;lt; 1000; i++ { 19 go Add() 20 } 21 22 time.Sleep(time.Second) 23 fmt.Println(number) 24} 25 26func Add() { 27 number++ 28} 源代码可以在 Playground 查看。</description></item><item><title>Go源码解析之atomic</title><link>/posts/2020/11/go-src/sync/atomic/</link><pubDate>Sun, 08 Nov 2020 20:16:35 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/11/go-src/sync/atomic/</guid><description>今天我们来聊聊go的atomic pkg，atomic是go并发编程中最为基础的库。如果说它是go并发编程的基石一点也不为过，像标准库中大家使用率非常高的Mutex, RWMutex,WaitGroup,Once等的实现都依赖于atomic。
Atomic简介 atomic提供一系列用于实现同步功能的、底层的，原子的方法：
AddT 系列将增量增加到源值上，并返回新值。 CompareAndSwapT 系列比较两个变量的值，并进行交换。 SwapT系列交换值，并返回旧值。 LoadT 系列获取值。 StoreT 系列更新值。 Value 存储器，支持Load,Store。 这些方法是原子操作，不会被CPU中断，也就说在多个goroutine之间访问是安全的。
比如CompareAndSwapT方法，其实它包含多个步骤，在CPU执行时也是多个命令完成这个功能。
1if *addr == old { 2 *addr = new 3 return true 4} 5return false 那么go是如何让这些方法变成了原子操作呢？我们接着往下看。
刨根问底 为了搞清楚atomic到底是如何工作的，我们以CompareAndSwapInt32为例来分析。我打开了atomic的源代码。
1asm.s 2atomic_test.go 3doc.go 4example_test.go 5race.s 6value.go 7value_test.go 包内的文件数并不多，打开第一个asm.s，我们就看到非常重要的内容。
这是一个go汇编文件，我摘取了部分重要的内容。
1// +build !race 2 3#include &amp;#34;textflag.h&amp;#34; 4 5TEXT ·SwapInt32(SB),NOSPLIT,$0 6 JMP runtime∕internal∕atomic·Xchg(SB) 7 8// ...略去... 9 10TEXT ·CompareAndSwapInt32(SB),NOSPLIT,$0 11 JMP runtime∕internal∕atomic·Cas(SB) 12 13// .</description></item></channel></rss>