<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>mutex on Amazing-Gao 实在是高</title><link>/tags/mutex/</link><description>Recent content in mutex on Amazing-Gao 实在是高</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>amazing.gao@qq.com (AmazingGao)</managingEditor><webMaster>amazing.gao@qq.com (AmazingGao)</webMaster><copyright>Amazing-Gao — All rights reserved.</copyright><lastBuildDate>Mon, 16 Nov 2020 21:20:54 +0800</lastBuildDate><atom:link href="/tags/mutex/index.xml" rel="self" type="application/rss+xml"/><item><title>Go源码解析之mutex</title><link>/posts/2020/11/go-src/sync/mutex/</link><pubDate>Mon, 16 Nov 2020 21:20:54 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/11/go-src/sync/mutex/</guid><description>概要 今天我们来看看Go中的互斥锁 sync/mutex。
我们借用互斥锁在维基百科上的定义：互斥锁（英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。
在Go中我们无法直接操作线程，使用 go 关键字启动的是goroutine，但goroutine的背后还是操作系统的线程，所以在此我们讨论的是多个goroutine之间的互斥锁。
用法 互斥锁的使用非常简单，初始化一个mutex，它的默认状态是unlock的。
Lock 方法表示这是临界区的开始，后续代码在访问公共资源时是受控的。调用该方法时，如果互斥锁已经是加锁的状态，goroutine将一直阻塞，直到锁释放。
Unlock 方法表示这是临界区的结束，之前的代码在访问公共资源时是受控的，但之后的将不再受控。调用该方法时，如果互斥锁是未加锁的状态，将会产生一个runtime error。
举个反例 1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;runtime&amp;#34; 6 &amp;#34;sync&amp;#34; 7 &amp;#34;time&amp;#34; 8) 9 10var ( 11 number int 12 mutex sync.Mutex 13) 14 15func main() { 16 runtime.GOMAXPROCS(10) 17 18 for i := 0; i &amp;lt; 1000; i++ { 19 go Add() 20 } 21 22 time.Sleep(time.Second) 23 fmt.Println(number) 24} 25 26func Add() { 27 number++ 28} 源代码可以在 Playground 查看。</description></item></channel></rss>