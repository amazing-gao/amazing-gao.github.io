<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>code reivew on Amazing-Gao 实在是高</title><link>/tags/code-reivew/</link><description>Recent content in code reivew on Amazing-Gao 实在是高</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>amazing.gao@qq.com (AmazingGao)</managingEditor><webMaster>amazing.gao@qq.com (AmazingGao)</webMaster><copyright>Amazing-Gao — All rights reserved.</copyright><lastBuildDate>Fri, 22 Oct 2021 10:40:09 +0800</lastBuildDate><atom:link href="/tags/code-reivew/index.xml" rel="self" type="application/rss+xml"/><item><title>Go Code Review</title><link>/posts/2021/10/go/codereview/</link><pubDate>Fri, 22 Oct 2021 10:40:09 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2021/10/go/codereview/</guid><description>以此记录那些年 Code Review 遇到的坑😂。
变量作用域 变量应该遵循最小作用域的原则，否者可能引起错乱。
案例1 函数的功能是：将 MongoDB 数据库中所有 offline 是 false 的记录，同步到 Redis 中。
Bad tmpl 的作用域在 for 循环之外，在对每条查询结果做 cursor.Decode 时 tmpl 变量未被重置，这造成之前记录的值可能残留在这次 cursor.Decode 的结果中，从而导致数据错乱。
1func Foo(ctx context.Context) error { 2 cursor, err := mongodb.Database(&amp;#34;baz&amp;#34;).Collection(&amp;#34;qux&amp;#34;).Find(ctx, mongodb.M{&amp;#34;offline&amp;#34;: false}) 3 4 // tmpl 的作用域是在 for 循环之外 5 tmpl := &amp;amp;Tmpl{} 6 for cursor.Next(ctx) { 7 if err := cursor.Decode(tmpl); err != nil { 8 return err 9 } 10 11 bytes, err := json.</description></item></channel></rss>