<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>compile on Amazing-Gao 实在是高</title><link>/tags/compile/</link><description>Recent content in compile on Amazing-Gao 实在是高</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>amazing.gao@qq.com (AmazingGao)</managingEditor><webMaster>amazing.gao@qq.com (AmazingGao)</webMaster><copyright>Amazing-Gao — All rights reserved.</copyright><lastBuildDate>Wed, 24 Feb 2021 23:48:08 +0800</lastBuildDate><atom:link href="/tags/compile/index.xml" rel="self" type="application/rss+xml"/><item><title>Go工具链之compile初探</title><link>/posts/2021/02/go/compile/</link><pubDate>Wed, 24 Feb 2021 23:48:08 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2021/02/go/compile/</guid><description>在阅读 Go 源代码的过程，可以看到大量形如 //go:xxx 的注释，虽然很容易猜测到肯定是和编译相关的，但并不清晰，于是就想深入了解一下。
在日常编译可执行文件的过程中，我想大家使用最多的毫无疑问是 go build 。只需一行命令即可将庞大且复杂的项目源代码编译成可执行文件，Go 把复杂的编译过程设计的非常简单、友好。 但是其实 Go 和 C/C++ 一样，也分为 compile 和 link 两个过程，今天我们要讲的就是 compile 过程。
自举 Go 在 1.5 之前使用 C 实现编译器，在 1.5 实现了自举，也就是说 Go 的编译器是使用 Go 语言本身去实现的。 自举对编程语言来说是个里程碑，实现自举包括但不限于以下的好处：
语言通过自我编译、自我迭代，达到本身语言的真正成熟稳定 对编译器后端的优化不仅会优化以后所有编译出来的其它程序的效率，也会优化编译器本身的效率 使开发编译器的环境和使用这门语言开发的其它程序一致 摆脱其它语言的依赖和自我迭代 编译命令 Go 程序源码的编译可以通过以下命令行执行 go tool compile [flags] file...，简单来说该命令可以将同一个 package 的多个文件编译成一个 .o 文件，多个 .o 文件又可以被链接成一个可执行文件。
下面我们以一个简单的 hello world 程序来举例。
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 fmt.Println(&amp;#34;hello world&amp;#34;) 7} 执行编译命令，可以得到 main.</description></item></channel></rss>