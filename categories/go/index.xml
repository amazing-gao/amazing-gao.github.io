<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on Amazing-Gao 实在是高</title><link>/categories/go/</link><description>Recent content in go on Amazing-Gao 实在是高</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>amazing.gao@qq.com (AmazingGao)</managingEditor><webMaster>amazing.gao@qq.com (AmazingGao)</webMaster><copyright>Amazing-Gao — All rights reserved.</copyright><lastBuildDate>Fri, 22 Oct 2021 10:40:09 +0800</lastBuildDate><atom:link href="/categories/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Go Code Review</title><link>/posts/2021/10/go/codereview/</link><pubDate>Fri, 22 Oct 2021 10:40:09 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2021/10/go/codereview/</guid><description>以此记录那些年 Code Review 遇到的坑😂。
变量作用域 变量应该遵循最小作用域的原则，否者可能引起错乱。
案例1 函数的功能是：将 MongoDB 数据库中所有 offline 是 false 的记录，同步到 Redis 中。
Bad tmpl 的作用域在 for 循环之外，在对每条查询结果做 cursor.Decode 时 tmpl 变量未被重置，这造成之前记录的值可能残留在这次 cursor.Decode 的结果中，从而导致数据错乱。
1func Foo(ctx context.Context) error { 2 cursor, err := mongodb.Database(&amp;#34;baz&amp;#34;).Collection(&amp;#34;qux&amp;#34;).Find(ctx, mongodb.M{&amp;#34;offline&amp;#34;: false}) 3 4 // tmpl 的作用域是在 for 循环之外 5 tmpl := &amp;amp;Tmpl{} 6 for cursor.Next(ctx) { 7 if err := cursor.Decode(tmpl); err != nil { 8 return err 9 } 10 11 bytes, err := json.</description></item><item><title>Go工具链之compile初探</title><link>/posts/2021/02/go/compile/</link><pubDate>Wed, 24 Feb 2021 23:48:08 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2021/02/go/compile/</guid><description>在阅读 Go 源代码的过程，可以看到大量形如 //go:xxx 的注释，虽然很容易猜测到肯定是和编译相关的，但并不清晰，于是就想深入了解一下。
在日常编译可执行文件的过程中，我想大家使用最多的毫无疑问是 go build 。只需一行命令即可将庞大且复杂的项目源代码编译成可执行文件，Go 把复杂的编译过程设计的非常简单、友好。 但是其实 Go 和 C/C++ 一样，也分为 compile 和 link 两个过程，今天我们要讲的就是 compile 过程。
自举 Go 在 1.5 之前使用 C 实现编译器，在 1.5 实现了自举，也就是说 Go 的编译器是使用 Go 语言本身去实现的。 自举对编程语言来说是个里程碑，实现自举包括但不限于以下的好处：
语言通过自我编译、自我迭代，达到本身语言的真正成熟稳定 对编译器后端的优化不仅会优化以后所有编译出来的其它程序的效率，也会优化编译器本身的效率 使开发编译器的环境和使用这门语言开发的其它程序一致 摆脱其它语言的依赖和自我迭代 编译命令 Go 程序源码的编译可以通过以下命令行执行 go tool compile [flags] file...，简单来说该命令可以将同一个 package 的多个文件编译成一个 .o 文件，多个 .o 文件又可以被链接成一个可执行文件。
下面我们以一个简单的 hello world 程序来举例。
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 fmt.Println(&amp;#34;hello world&amp;#34;) 7} 执行编译命令，可以得到 main.</description></item><item><title>Go项目Gitlab CICD提速指南</title><link>/posts/2021/01/go/cicd/</link><pubDate>Sat, 16 Jan 2021 16:57:19 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2021/01/go/cicd/</guid><description>背景 我司使用GitLab作为代码仓库，Go项目在CICD过程中需要下载依赖，但大部分情况下依赖并未发生变化，重复下载是无用且非常耗时的操作，严重拖慢了CICD的效率。这对于任何一个追求效率的团队来说都是无法接受的。
之前也了解到一些go依赖缓存的解决方案，但不是特别优雅。从 Go 1.15 Release Notes 中看到，该版本新增了 GOMODCACHE 环境变量的支持，官方说明如下：
The location of the module cache may now be set with the GOMODCACHE environment variable. The default value of GOMODCACHE is GOPATH[0]/pkg/mod, the location of the module cache before this change. A workaround is now available for Windows &amp;quot;Access is denied&amp;quot; errors in go commands that access the module cache, caused by external programs concurrently scanning the file system (see issue #36568).</description></item><item><title>Go源码解析之mutex</title><link>/posts/2020/11/go-src/sync/mutex/</link><pubDate>Mon, 16 Nov 2020 21:20:54 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/11/go-src/sync/mutex/</guid><description>概要 今天我们来看看Go中的互斥锁 sync/mutex。本文基于go1.15.5 进行分析。
我们借用互斥锁在维基百科上的定义：互斥锁（英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。
在Go中我们无法直接操作线程，使用 go 关键字启动的是goroutine，但goroutine的背后还是操作系统的线程，所以在此我们讨论的是多个goroutine之间的互斥锁。
用法 互斥锁的使用非常简单，初始化一个mutex，它的默认状态是unlock的。
Lock 方法表示这是临界区的开始，后续代码在访问公共资源时是受控的。调用该方法时，如果互斥锁已经是加锁的状态，goroutine将一直阻塞，直到锁释放。
Unlock 方法表示这是临界区的结束，之前的代码在访问公共资源时是受控的，但之后的将不再受控。调用该方法时，如果互斥锁是未加锁的状态，将会产生一个runtime error。
举个反例 1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;runtime&amp;#34; 6 &amp;#34;sync&amp;#34; 7 &amp;#34;time&amp;#34; 8) 9 10var ( 11 number int 12 mutex sync.Mutex 13) 14 15func main() { 16 runtime.GOMAXPROCS(10) 17 18 for i := 0; i &amp;lt; 1000; i++ { 19 go Add() 20 } 21 22 time.Sleep(time.Second) 23 fmt.Println(number) 24} 25 26func Add() { 27 number++ 28} 源代码可以在 Playground 查看。</description></item><item><title>Go条件编译</title><link>/posts/2020/11/go/build-constraints/</link><pubDate>Fri, 13 Nov 2020 18:39:55 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/11/go/build-constraints/</guid><description>最近在开发过程中遇到一个比较在编码上无解的问题，最终通过条件编译得到一个比较满意的方案。对于Go的条件编译，可能很多人都了解，甚至不知道。Go通过在行注释的前面编写如下代码来实现条件编译。
1// +build 条件编译的指令可能出现在任何源代码中，不止是*.go文件，可能是go汇编文件。无论是何种源文件，条件编译指令一定都出现在文件的顶部，并且在空行或者其他行注释之前。所以条件编译指令也必须在package语句之前。
编译规则 可以将 // +build 后面的内容当成一个表达式。当表达式返回true时，当前文件参与编译，反之不参与编译。
多个片段之间的空格表示它们之间是OR的关系。如下，表示GOOS值是linux或者darwin时，本文件参与编译。
1// +build linux darwin 多个片段之间的,表示它们之间是AND的关系。如下，表示GOOS值是linux且是amd64架构时，本文件参与编译。 1// +build linux,amd64 以!xxx开头的片段表示当tag xxx设置时，当前文件不参与编译。如下，表示GOOS值是linux时，本文件不参与编译。 1// +build !linux 单文件包含多个条件编译指令时，它们是AND的关系。如下，表示GOOS值是linux且是amd64架构时，本文件参与编译。 1// +build linux 2// +build amd64 一些内建的关键字。
GOOS的值，目标操作系统，如linux,darwin。 GOARCH的值，目标架构，如amd64。 编译器，gc 或者 gccgo。 cgo 如果cgo支持，编译。 gox.x 只在特定go版本进行编译，不支持beta or minor版本号的条件编译。 go build 命令的其他tag。 文件名实现条件编译。条件编译支持以下三种格式（源码文件名去除类型后缀和_test后缀后）：
*_GOOS GOOS值与文件名中的GOOS一致时参与编译。 *_GOARCH GOARCH值与文件名中的GOARCH一致时参与编译。 *_GOOS_GOARCH GOARCH,GOOS值与文件名中的GOARCH,GOOS一致时参与编译。 如 source_windows_amd64.go 该文件只在windows系统的amd64架构下进行编译。</description></item><item><title>Go源码解析之atomic</title><link>/posts/2020/11/go-src/sync/atomic/</link><pubDate>Sun, 08 Nov 2020 20:16:35 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/11/go-src/sync/atomic/</guid><description>今天我们来聊聊go的atomic pkg，atomic是go并发编程中最为基础的库。如果说它是go并发编程的基石一点也不为过，像标准库中大家使用率非常高的Mutex, RWMutex,WaitGroup,Once等的实现都依赖于atomic。
Atomic简介 atomic提供一系列用于实现同步功能的、底层的，原子的方法：
AddT 系列将增量增加到源值上，并返回新值。 CompareAndSwapT 系列比较两个变量的值，并进行交换。 SwapT系列交换值，并返回旧值。 LoadT 系列获取值。 StoreT 系列更新值。 Value 存储器，支持Load,Store。 这些方法是原子操作，不会被CPU中断，也就说在多个goroutine之间访问是安全的。
比如CompareAndSwapT方法，其实它包含多个步骤，在CPU执行时也是多个命令完成这个功能。
1if *addr == old { 2 *addr = new 3 return true 4} 5return false 那么go是如何让这些方法变成了原子操作呢？我们接着往下看。
刨根问底 为了搞清楚atomic到底是如何工作的，我们以CompareAndSwapInt32为例来分析。我打开了atomic的源代码。
1asm.s 2atomic_test.go 3doc.go 4example_test.go 5race.s 6value.go 7value_test.go 包内的文件数并不多，打开第一个asm.s，我们就看到非常重要的内容。
这是一个go汇编文件，我摘取了部分重要的内容。
1// +build !race 2 3#include &amp;#34;textflag.h&amp;#34; 4 5TEXT ·SwapInt32(SB),NOSPLIT,$0 6 JMP runtime∕internal∕atomic·Xchg(SB) 7 8// ...略去... 9 10TEXT ·CompareAndSwapInt32(SB),NOSPLIT,$0 11 JMP runtime∕internal∕atomic·Cas(SB) 12 13// .</description></item><item><title>Go设计模式之Factory</title><link>/posts/2020/10/factory/</link><pubDate>Wed, 14 Oct 2020 20:30:39 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/10/factory/</guid><description>Factory - 工厂模式 工厂模式在Go中使用的非常广泛，比如常用于数据的读写模块。假设我们需要从某种介质中读取数据，并将更新后的结果保存到该介质中。考虑到以后可能更换为其他类型的介质，为了避免日后更换介质而大面积变更代码，我们就会用到本模式。
实现 1.定义工厂方法所创建对象的接口 假设我们的存储模块只有Read和Write两个功能，我们需要先定义存储器inteface。
1package store 2 3import &amp;#34;io&amp;#34; 4 5type Store interface { 6 Read(string) ([]byte, error) 7 Save(string, []byte) (error) 8} 2.实现对象接口 假设我们需要将Redis或磁盘作为存储介质，我们需要分别实现Redis与磁盘的存储功能。
FileSystem 1pacakge store 2 3type FileStore struct{ 4 /*your codes*/ 5} 6 7func (store *FileStore) Read(string) ([]byte, error) { 8 /*your codes*/ 9} 10 11func (store *FileStore) Save(string, []byte) (error) { 12 /*your codes*/ 13} 14 15// 注意这里要返回 Store 接口，而不是FileStore的指针。 16// 可以保证工厂方法只能调用到对象接口方法，避免封装被破坏。 17func newFileStore() Store { 18 /*your codes*/ 19} Redis 1pacakge store 2 3type RedisStore struct{ 4 /*your codes*/ 5} 6 7func (store *RedisStore) Read(string) ([]byte, error) { 8 /*your codes*/ 9} 10 11func (store *RedisStore) Save(string, []byte) (error) { 12 /*your codes*/ 13} 14 15// 注意这里要返回 Store 接口，而不是RedisStore的指针。 16// 可以保证工厂方法只能调用到对象接口方法，避免封装被破坏。 17func newRedisStore() Store { 18 /*your codes*/ 19} 3.</description></item><item><title>Go设计模式之Singleton</title><link>/posts/2020/09/go-patterns/singleton/</link><pubDate>Wed, 30 Sep 2020 22:40:58 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/09/go-patterns/singleton/</guid><description>Singleton - 单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点。
实现 饿汉式 饿汉式单例是指在方法调用前，实例就已经创建好了。
按照用法使用，可以看到控制台输出10次单例的内存地址是一样的。
1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;sync&amp;#34; 6 &amp;#34;time&amp;#34; 7) 8 9type ( 10 server struct { 11 port int 12 } 13) 14 15var ( 16 instance = &amp;amp;server{} 17) 18 19func getServerSingleton() *server { 20 return instance 21} 22 23/* 24server ptr: 0x1182ec0 25server ptr: 0x1182ec0 26server ptr: 0x1182ec0 27server ptr: 0x1182ec0 28server ptr: 0x1182ec0 29server ptr: 0x1182ec0 30server ptr: 0x1182ec0 31server ptr: 0x1182ec0 32server ptr: 0x1182ec0 33server ptr: 0x1182ec0 34*/ 懒汉式 - 非Goroutine安全 懒汉式单例是指在方法调用获取实例时才创建实例，因为相对饿汉式显得“不急迫”，所以被叫做“懒汉模式”。</description></item><item><title>Go工具链之godoc</title><link>/posts/2020/09/go/godoc/</link><pubDate>Sun, 27 Sep 2020 21:30:30 +0800</pubDate><author>amazing.gao@qq.com (AmazingGao)</author><guid>/posts/2020/09/go/godoc/</guid><description>在写boxgo的过程中，想要生成漂亮的godoc，发现不太熟悉godoc的用法，所以就有了本篇文章，记录一下。
Go团队非常重视文档，文档对项目的可阅读性、可维护性起到重要作用，所以写好文档变得非常重要。Go团队提供了godoc工具以帮助开发者方便、准确，容易的生成项目文档。godoc解析Go源代码（包括注释），并以HTML或纯文本格式生成文档。
生成文档 提取规则：
类型、变量、常量、函数，包都可以通过在声明的前面写注释的方法生成文档（中间不要有空行）。
1// Package doc 包注释 --- good 2package doc 3 4type ( 5 // UserType 类型注释 --- good 6 UserType string 7) 8 9var ( 10 // userType 变量注释 --- good 11 userType UserType 12) 13 14const ( 15 // Zero 常量注释 --- good 16 Zero = 0 17) 18 19// Test 函数注释 --- good 20func Test() { 21 22} 23 24 25// Test1 函数注释 --- bad（不要有空行） 26 27func Test1() { 28 29} 注释开头的字母需要与被注释的元素名称保持一致（包除外）。如函数Fprint注释开头的第一个字母也是Fprint。</description></item></channel></rss>