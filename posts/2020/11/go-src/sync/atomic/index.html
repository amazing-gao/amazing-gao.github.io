<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>Go源码解析之atomic | Amazing-Gao 实在是高</title><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=description content="今天我们来聊聊go的atomic pkg，atomic是go并发编程中最为基础的库。如果说它是go并发编程的基石一点也不为过，像标准库中大家使用率非常高的Mutex, RWMutex,WaitGroup,Once等的实现都依赖于atomic。
Atomic简介 atomic提供一系列用于实现同步功能的、底层的，原子的方法：
 AddT 系列将增量增加到源值上，并返回新值。 CompareAndSwapT 系列比较两个变量的值，并进行交换。 SwapT系列交换值，并返回旧值。 LoadT 系列获取值。 StoreT 系列更新值。 Value 存储器，支持Load,Store。  这些方法是原子操作，不会被CPU中断，也就说在多个goroutine之间访问是安全的。
比如CompareAndSwapT方法，其实它包含多个步骤，在CPU执行时也是多个命令完成这个功能。
if *addr == old { *addr = new return true } return false 那么go是如何让这些方法变成了原子操作呢？我们接着往下看。
刨根问底 为了搞清楚atomic到底是如何工作的，我们以CompareAndSwapInt32为例来分析。我打开了atomic的源代码。
asm.s atomic_test.go doc.go example_test.go race.s value.go value_test.go 包内的文件数并不多，打开第一个asm.s，我们就看到非常重要的内容。
这是一个go汇编文件，我摘取了部分重要的内容。
// +build !race #include &#34;textflag.h&#34; TEXT ·SwapInt32(SB),NOSPLIT,$0 JMP	runtime∕internal∕atomic·Xchg(SB) // ...略去... TEXT ·CompareAndSwapInt32(SB),NOSPLIT,$0 JMP	runtime∕internal∕atomic·Cas(SB)	// ...略去... TEXT ·AddInt32(SB),NOSPLIT,$0 JMP	runtime∕internal∕atomic·Xadd(SB) // ...略去... TEXT ·LoadInt32(SB),NOSPLIT,$0 JMP	runtime∕internal∕atomic·Load(SB)	// ."><meta name=author content="AmazingGao"><meta name=generator content="Hugo 0.78.1"><link href=/index.xml rel=alternate type=application/rss+xml title="Amazing-Gao 实在是高 Feed"><link rel=stylesheet href=/style.7c6d960b20273ed88bc63a60591a57e7739fb21f243b77f27c3bc730ef6205c0.css><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?815a521e3c0aee7749c5f8350acb8c6d";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script><script defer src=/script.9df38729991a6ec08d83b60514e841529cebd5ccc800cf8e1f98fb63e73aaa73.js></script></head><body><div class=pure-g><div class="pure-u-1-24 pure-u-md-5-24"></div><div class="pure-u-22-24 pure-u-md-14-24"><div class=navigation><div class="navigation-header clearfix"><div class="pure-menu pure-menu-horizontal"><a class="pure-menu-heading pure-menu-link" href=/>Amazing-Gao 实在是高</a><ul class="pure-menu-list navigation-header-subtitle pull-end"><li class="pure-menu-item pure-menu-disabled">Find, discover, explorer and enjoy!</li></ul></div></div><div class=navigation-content><div class="pure-menu pure-menu-horizontal"><ul class=pure-menu-list><li class=pure-menu-item title="All posts"><a class=pure-menu-link href=/posts/>Posts</a></li><li class=pure-menu-item title="All tags"><a class=pure-menu-link href=/tags/>Tags</a></li><li class=pure-menu-item title="All series"><a class=pure-menu-link href=/series/>Series</a></li><li class=pure-menu-item title="All categories"><a class=pure-menu-link href=/categories/>Categories</a></li><li class=pure-menu-item title="About me"><a class=pure-menu-link href=/about/>About</a></li></ul></div></div></div><div><div><h2 class=post-title>Go源码解析之atomic</h2><div class=post-meta><span>Date</span> [
<time datetime=2020-11-08T20:16:35+08:00>2020-11-08</time>
]
<span>Categories</span> [
<a href=/categories/go>go</a>
]
<span>Series</span> [
<a href=/series/go%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90>Go源码解析</a>
]
<span>Tags</span> [
<a href=/tags/go>go</a>
<a href=/tags/sync>sync</a>
<a href=/tags/atomic>atomic</a>
]</div></div><div><p>今天我们来聊聊go的<strong>atomic</strong> pkg，<strong>atomic</strong>是go并发编程中最为基础的库。如果说它是go并发编程的基石一点也不为过，像标准库中大家使用率非常高的<strong>Mutex</strong>, <strong>RWMutex</strong>,<strong>WaitGroup</strong>,<strong>Once</strong>等的实现都依赖于<strong>atomic</strong>。</p><h1 id=atomic简介>Atomic简介</h1><p><strong>atomic</strong>提供一系列用于实现同步功能的、底层的，原子的方法：</p><ol><li><strong>AddT</strong> 系列将增量增加到源值上，并返回新值。</li><li><strong>CompareAndSwapT</strong> 系列比较两个变量的值，并进行交换。</li><li><strong>SwapT</strong>系列交换值，并返回旧值。</li><li><strong>LoadT</strong> 系列获取值。</li><li><strong>StoreT</strong> 系列更新值。</li><li><strong>Value</strong> 存储器，支持Load,Store。</li></ol><p>这些方法是原子操作，不会被CPU中断，也就说在多个goroutine之间访问是安全的。</p><p>比如<strong>CompareAndSwapT</strong>方法，其实它包含多个步骤，在CPU执行时也是多个命令完成这个功能。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>addr</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>old</span> {
	<span style=color:#f92672>*</span><span style=color:#a6e22e>addr</span> = <span style=color:#a6e22e>new</span>
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
}
<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</code></pre></div><p>那么go是如何让这些方法变成了原子操作呢？我们接着往下看。</p><h1 id=刨根问底>刨根问底</h1><p>为了搞清楚<strong>atomic</strong>到底是如何工作的，我们以<strong>CompareAndSwapInt32</strong>为例来分析。我打开了<a href=https://github.com/golang/go/tree/master/src/sync/atomic>atomic</a>的源代码。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>asm.s
atomic_test.go
doc.go
example_test.go
race.s
value.go
value_test.go
</code></pre></div><p>包内的文件数并不多，打开第一个<strong>asm.s</strong>，我们就看到非常重要的内容。</p><p>这是一个go汇编文件，我摘取了部分重要的内容。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>// +build !race

#include &#34;textflag.h&#34;

TEXT ·SwapInt32(SB),NOSPLIT,$0
	JMP	runtime∕internal∕atomic·Xchg(SB)

// ...略去...

TEXT ·CompareAndSwapInt32(SB),NOSPLIT,$0
	JMP	runtime∕internal∕atomic·Cas(SB)	

// ...略去...

TEXT ·AddInt32(SB),NOSPLIT,$0
	JMP	runtime∕internal∕atomic·Xadd(SB)
	
// ...略去...
	
TEXT ·LoadInt32(SB),NOSPLIT,$0
	JMP	runtime∕internal∕atomic·Load(SB)	

// ...略去...

TEXT ·StoreInt32(SB),NOSPLIT,$0
	JMP	runtime∕internal∕atomic·Store(SB)	
</code></pre></div><p><code>// +build !race</code> 这是go的条件编译，表示race时不编译，不是本文重点，欲知更多请查看<a href=https://golang.org/cmd/go/#hdr-Build_constraints>Go build constraints</a>。<code>#include "textflag.h"</code> 引用头文件，定义了一些宏。</p><p>下面来到我们的重点 <code>TEXT ·CompareAndSwapInt32(SB),NOSPLIT,$0</code> 定义了CompareAndSwapInt32函数，可以看到它并没有什么逻辑，直接跳转去了<code>runtime∕internal∕atomic·Cas</code>。那么我们就跟过去。</p><p>我们查看amd64版本代码<a href=https://github.com/golang/go/blob/master/src/runtime/internal/atomic/stubs.go#L12>stubs.go</a>，看到了函数的声明*<em>func Cas(ptr <em>uint32, old, new uint32) bool</em></em>，但是并没有函数体。Go还可以这么玩？函数体去哪里了？</p><p>经过一番侦查，在<a href=https://github.com/golang/go/blob/master/src/runtime/internal/atomic/asm_amd64.s#L17>asm_amd64.s</a>中发现了汇编实现的函数体。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>// bool Cas(int32 *val, int32 old, int32 new)
// Atomically:
//	if(*val == old){
//		*val = new;
//		return 1;
//	} else
//		return 0;
TEXT runtime∕internal∕atomic·Cas(SB),NOSPLIT,$0-17
	MOVQ	ptr+0(FP), BX
	MOVL	old+8(FP), AX
	MOVL	new+12(FP), CX
	LOCK
	CMPXCHGL	CX, 0(BX)
	SETEQ	ret+16(FP)
	RET
</code></pre></div><p>第一行MOVQ ptr到BX寄存器。<strong>FP</strong> 是go汇编定义的伪寄存器，伪FP寄存器对应的是函数的帧指针，一般用来访问函数的参数和返回值。Go汇编是基于<a href=https://9p.io/sys/doc/asm.html>plan9</a>的，MOV的方向和我们常规学习到的相反。</p><p>第二行MOVL old值到AX寄存器。</p><p>第三行MOVL new值到CX寄存器。</p><p>第四行<strong>LOCK</strong>，这个命令非常陌生。经过一番资料查询了解到<a href=https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf>Intel® 64 and IA-32 Architectures Software Developer’s Manual</a>，LOCK能将后续的指令变成原子操作，那么后续的<strong>CMPXCHGL</strong>也将被原子化。</p><p>第五行CMPXCHGL CX, 0(BX)，将BX的值(ptr)与CX的值(new)比较。如果相等，CX更新到ptr，否者BX更新到AX。</p><p>第六行SETEQ ret+16(FP)，如果ZF标志位为0，设置1到返回值(FP偏移16位)，否者设置0。</p><p>第七行RET 函数返回。</p><hr><p>这里最重要的是<strong>LOCK</strong>与<strong>CMPXCHGL</strong>两个命令，两条命令组合完成了Cas操作。这是CPU支持的原子操作。后续补充CPU这块关于LOCK的一些介绍。</p><hr><p>atomic中其他方法实现原子操作的方案基本与此一致，在此就不赘述了，有兴趣的童鞋可以自己研究一下。</p><h1 id=参考文档>参考文档：</h1><ol><li><a href=https://wweir.cc/post/%E6%8E%A2%E7%B4%A2-golang-%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E8%AF%AD/>探索 Golang 一致性原语</a></li></ol></div></div><div class=footer><div class="pure-menu pure-menu-horizontal"><ul class=pure-menu-list><li class=pure-menu-item title="My repository"><a class=pure-menu-link href=https://github.com/amazing-gao>GitHub</a></li><li class=pure-menu-item title="RSS Feed"><a href=/index.xml class=pure-menu-link>RSS</a></li><li class="pure-menu-item fix-cursor-pointer" title="Go to top"><a class=pure-menu-link id=btn-gototop><span class=fix-placement-up>&#8679;&#xfe0e;</span></a></li></ul></div><div class="pure-menu pure-menu-horizontal"><ul class=pure-menu-list><li class="pure-menu-item pure-menu-disabled">&copy; 2020 &mdash; Amazing-Gao — All rights reserved.</li></ul></div></div></div><div class="pure-u-1-24 pure-u-md-5-24"></div></div></body></html>